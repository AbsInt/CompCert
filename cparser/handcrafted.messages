#######################################################################
#                                                                     #
#              The Compcert verified compiler                         #
#                                                                     #
#        FranÃ§ois Pottier, INRIA Paris-Rocquencourt                   #
#        Jacques-Henri Jourdan, INRIA Paris-Rocquencourt              #
#                                                                     #
#  Copyright Institut National de Recherche en Informatique et en     #
#  Automatique.  All rights reserved.  This file is distributed       #
#  under the terms of the GNU Lesser General Public License as        #
#  published by the Free Software Foundation, either version 2.1 of   #
#  the License, or (at your option) any later version.                #
#  This file is also distributed under the terms of the               #
#  INRIA Non-Commercial License Agreement.                            #
#                                                                     #
#######################################################################

# This file contains a complete list of sentences that cause the pre_parser to
# detect an error.

# ------------------------------------------------------------------------------

# WORKFLOW:

# The workflow (when and how this file should be modified; which tools exist
# to maintain it; etc.) is documented in GNUmakefile in this directory.

# ------------------------------------------------------------------------------

# FILE FORMAT:

# Each sentence is followed with a hand-written error message, which must be
# preceded and followed by a blank line.

# If several sentences should share a single error message, they can be grouped,
# with no whitespace between them.

# Hand-written comments, which begin with a single hash character, like this, are
# preserved when this file is updated by Menhir. Auto-generated comments, which
# begin with two hash characters, are re-generated by Menhir.

# An error message is basically free-form text. It cannot contain a blank line.
# Occurrences of the special form $i, where i is a number (an index into the
# parser's stack), will be replaced by the fragment of the source text that
# corresponds to this stack entry. It is the user's responsibility to ensure
# that the index i is within range, i.e., falls into the known suffix of the
# stack. Note that this index is 0-based and counts from right to left, i.e.,
# $0 refers to the RIGHTMOST stack cell.

# The replacement text for $i can be quite long (up to one line, basically)
# so one should avoid using several $i on a single line, unless one knows
# a smaller bound on their length.

# ------------------------------------------------------------------------------

# CONVENTIONS ABOUT THE FORM AND STYLE OF ERROR MESSAGES:

# If possible, start with "Ill-formed foo", where "foo" is the thing that we
# are trying to recognize, i.e., the left-hand side of our items. This is not
# always possible, as we do not always know with certainty what we are trying
# to rcognize.

# If possible, say "Up to this point, a bar has been recognized", and show it,
# by using $i.

# If the current state was reached via spurious reductions, print a hypothesis,
# of the form "If this bar is complete, then".

# Show a list of the permitted continuations: "at this point, one of the
# following is expected:". The list should be complete, although unlikely
# continuations can be omitted. A continuation can be just one symbol, or
# a sequence of symbols.

# ------------------------------------------------------------------------------

# NOTE ON THE CONTEXT OF AN EXPRESSION:

# A C expression occurs in many contexts.

# Although we could distinguish between these contexts statically, by adding a
# phantom parameter to all of the nonterminal symbols that encode expressions,
# that would be quite heavy: the number of states in the automaton would grow
# quite dramatically.

# Instead, we prefer to dynamically distinguish between these contexts. We do
# so in a very simple way: we give %on_error_reduce declarations to Menhir (in
# pre_parser.mly) so as to replace certain error actions with reduction actions.
# Thus, when Menhir finds an error and whatever is on the stack can be reduced
# to an expression, the automaton will reduce it to an expression. By carrying
# out this extra (spurious) reduction, the automaton ends up in a state where
# sufficient static context is available to tell what should follow. Thus,
# without doing anything special beyond giving these directives, we are able
# to sidestep the issue of the context of expressions.

# Of course, we must be careful to say (in our error messages) "IF this
# expression (or list of expressions) is complete, THEN the following
# continuations are expected". The weakness of this approach is that if the
# expression is NOT complete (in the user's mind), then we do not help the user
# understand how the expression should be completed. Our error message exhibits
# a bias towards ending expressions.

# OTHER USES OF %on_error_reduce:

# We apply this technique also to attribute_specifier_list and declarator. This
# means, intuitively, that when we find an error at a position where an
# attribute specifier list and/or a declarator could be complete, but could also
# be continued, we implicitly assume it is complete. Again, this must be taken
# into account in messages where an attribute_specifier_list or a declarator has
# just been recognized.

# ABOUT STRICT VERSUS LAX INTERPRETATIONS OF %on_error_reduce:

# There are two ways in which Menhir could implement %on_error_reduce. In the
# strict interpretation, an extra reduction takes place only if this is the
# only reduction that can take place in this state. (Thus, we do not choose
# between two interpretations of the past.) In the lax interpretation, an extra
# reduction can take place even if some other reduction is enabled. (In a
# situation where two extra reductions compete, neither takes place.)

# Adopting the lax interpretation adds more extra reductions, causing some
# error states to disappear. For instance, this state, where we have a read
# a VAR_NAME which could be either the beginning of an expression or the
# beginning of a labeled statement:

# general_identifier -> PRE_NAME VAR_NAME . [ COLON ]
# primary_expression -> PRE_NAME VAR_NAME . [ <lots of tokens> ]

# In the strict interpretation, no extra reduction is permitted here, because
# two reductions are enabled. In the lax interpretation, because we have 
# declared %on_error_reduce primary_expression, the second production is
# reduced. Hence, we implicitly assume that this name forms an expression
# (as opposed to a label). This is slightly inaccurate (we lose completeness)
# but removes an error state that is rather unpleasant.

# Even though it may sound "bad" to arbitrarily force one reduction among
# several possible reductions, one should keep in mind that an arbitrary
# choice is already made for us by the user when he "chooses" the incorrect
# token. Indeed, depending on which incorrect token is used, we may fall
# within or outside of a lookahead set, so we may make different reduction
# choices, and give different error messages. So, we shouldn't feel too bad
# about forcing a few more arbitrary choices. This is actually more regular,
# in a sense.

# In another instance of this phenomemon, there is a rather tricky state,
# where we have read "int f" at the toplevel, and we do not know whether this
# will be a variable definition (declarator) or a function definition
# (direct_declarator). In the lax interpretation, because we have declared
# %on_error_reduce declarator, we implicitly assume this must be the
# beginning of a declarator. Again, we lose completeness (we will not suggest
# that an opening parenthesis would have been accepted) but this makes our
# life easier, and does not sound too bad.

# Another instance is a state where we have read "enum foo". This could be a
# complete enum_specifier, or it could be continued with an opening brace. If it
# is complete, though, we lack static context to tell what should come after it.
# Using lax %on_error_reduce enum_specifier allows us to force a reduction,
# (thus forgetting that an opening brace would have been permitted) and to move
# to another state where more contextual information is available. As noted
# above, this reduction can already take place naturally, depending on the
# lookahead token, so we are only adding more cases where it takes place.

# The lax %on_error_reduce is used also to deal with a family of error states
# where we have recognized a complete statement which could be continued with an
# ELSE branch. These error states are difficult to explain: although we can
# definitely say that ELSE is permitted, we have difficulty telling what else is
# permitted, by lack of static context. We could recover this static information
# by introducing a phantom parameter on statements, but that would be heavy. We
# just cut a corner and use %on_error_reduce to view this as a complete
# statement. Thus, we abandon the possibility that the statement could be
# continued with ELSE: our error message will not mention it. Again, this makes
# our life easier, and does not sound too bad.

# We also apply %on_error_reduce to specifier_qualifier_list and
# option(abstract_declarator(type_name)). This allows us to recognize
# a valid type name, even when this type name could be continued. This
# allows us to go back to a state where we see the opening parenthesis
# before the type name (there is always one), which allows us to
# explain why we request a closing parenthesis. This is a bit costly,
# as there are quite a few similar error states to deal with here.

# ------------------------------------------------------------------------------

translation_unit_file: ALIGNAS LPAREN INT XOR_ASSIGN
##
## Ends in an error in state: 322.
##
## attribute_specifier -> ALIGNAS LPAREN type_name . RPAREN [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE STRUCT STRING_LITERAL STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER RBRACK PRE_NAME PLUS PACKED NORETURN MINUS LPAREN LONG LBRACK LBRACE INT INLINE INC FLOAT EXTERN EQ ENUM DOUBLE DEC CONSTANT CONST COMMA COLON CHAR BUILTIN_VA_ARG BUILTIN_OFFSETOF BANG AUTO ATTRIBUTE AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## ALIGNAS LPAREN type_name
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 67, spurious reduction of production specifier_qualifier_list(type_name) -> type_specifier_no_typedef_name list(specifier_qualifier_no_typedef_name) 
## In state 314, spurious reduction of production option(abstract_declarator(type_name)) -> 
## In state 320, spurious reduction of production type_name -> specifier_qualifier_list(type_name) option(abstract_declarator(type_name)) 
##

# Maybe the type name was not complete, but we have reduced anyway
# and assume it is complete. Thus, we expect a closing parenthesis.
# This example comes in several variants, because there are several
# places in the grammar where LPAREN type_name RPAREN appears.

# gcc, clang: like us, expect a closing parenthesis.

Ill-formed _Alignas qualifier.
Up to this point, a type name has been recognized:
  $0
If this type name is complete,
then at this point, a closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ ALIGNOF LPAREN VOID XOR_ASSIGN
##
## Ends in an error in state: 312.
##
## unary_expression -> ALIGNOF LPAREN type_name . RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LEQ LEFT_ASSIGN LEFT HAT GT GEQ EQEQ EQ DIV_ASSIGN COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## ALIGNOF LPAREN type_name
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 67, spurious reduction of production specifier_qualifier_list(type_name) -> type_specifier_no_typedef_name list(specifier_qualifier_no_typedef_name) 
## In state 314, spurious reduction of production option(abstract_declarator(type_name)) -> 
## In state 320, spurious reduction of production type_name -> specifier_qualifier_list(type_name) option(abstract_declarator(type_name)) 
##
translation_unit_file: INT PRE_NAME VAR_NAME EQ SIZEOF LPAREN VOID XOR_ASSIGN
##
## Ends in an error in state: 396.
##
## postfix_expression -> LPAREN type_name . RPAREN LBRACE initializer_list option(COMMA) RBRACE [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
## unary_expression -> SIZEOF LPAREN type_name . RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LEQ LEFT_ASSIGN LEFT HAT GT GEQ EQEQ EQ DIV_ASSIGN COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## SIZEOF LPAREN type_name
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 67, spurious reduction of production specifier_qualifier_list(type_name) -> type_specifier_no_typedef_name list(specifier_qualifier_no_typedef_name) 
## In state 314, spurious reduction of production option(abstract_declarator(type_name)) -> 
## In state 320, spurious reduction of production type_name -> specifier_qualifier_list(type_name) option(abstract_declarator(type_name)) 
##

Ill-formed use of $2.
Up to this point, a type name has been recognized:
  $0
If this type name is complete,
then at this point, a closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ BUILTIN_VA_ARG LPAREN PRE_NAME VAR_NAME COMMA VOID XOR_ASSIGN
##
## Ends in an error in state: 341.
##
## postfix_expression -> BUILTIN_VA_ARG LPAREN assignment_expression COMMA type_name . RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## BUILTIN_VA_ARG LPAREN assignment_expression COMMA type_name
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 67, spurious reduction of production specifier_qualifier_list(type_name) -> type_specifier_no_typedef_name list(specifier_qualifier_no_typedef_name) 
## In state 314, spurious reduction of production option(abstract_declarator(type_name)) -> 
## In state 320, spurious reduction of production type_name -> specifier_qualifier_list(type_name) option(abstract_declarator(type_name)) 
##

Ill-formed use of __builtin_va_arg.
Up to this point, a type name has been recognized:
  $0
If this type name is complete,
then at this point, a closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ INC LPAREN VOID XOR_ASSIGN
##
## Ends in an error in state: 371.
##
## postfix_expression -> LPAREN type_name . RPAREN LBRACE initializer_list option(COMMA) RBRACE [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## LPAREN type_name
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 67, spurious reduction of production specifier_qualifier_list(type_name) -> type_specifier_no_typedef_name list(specifier_qualifier_no_typedef_name) 
## In state 314, spurious reduction of production option(abstract_declarator(type_name)) -> 
## In state 320, spurious reduction of production type_name -> specifier_qualifier_list(type_name) option(abstract_declarator(type_name)) 
##

# gcc simply says it expects a closing parenthesis,
# but clang says it expects a closing parenthesis and an opening brace.

Ill-formed compound literal.
Up to this point, a type name has been recognized:
  $0
If this type name is complete,
then at this point, a closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ LPAREN VOID XOR_ASSIGN
##
## Ends in an error in state: 393.
##
## cast_expression -> LPAREN type_name . RPAREN cast_expression [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LEQ LEFT_ASSIGN LEFT HAT GT GEQ EQEQ EQ DIV_ASSIGN COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
## postfix_expression -> LPAREN type_name . RPAREN LBRACE initializer_list option(COMMA) RBRACE [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## LPAREN type_name
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 67, spurious reduction of production specifier_qualifier_list(type_name) -> type_specifier_no_typedef_name list(specifier_qualifier_no_typedef_name) 
## In state 314, spurious reduction of production option(abstract_declarator(type_name)) -> 
## In state 320, spurious reduction of production type_name -> specifier_qualifier_list(type_name) option(abstract_declarator(type_name)) 
##

# gcc and clang say they expect a closing parenthesis.

Up to this point, a type name has been recognized:
  $0
If this type name is complete,
then at this point, a closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: ALIGNAS LPAREN PRE_NAME VAR_NAME SEMICOLON
##
## Ends in an error in state: 324.
##
## argument_expression_list -> argument_expression_list . COMMA assignment_expression [ RPAREN COMMA ]
## attribute_specifier -> ALIGNAS LPAREN argument_expression_list . RPAREN [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE STRUCT STRING_LITERAL STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER RBRACK PRE_NAME PLUS PACKED NORETURN MINUS LPAREN LONG LBRACK LBRACE INT INLINE INC FLOAT EXTERN EQ ENUM DOUBLE DEC CONSTANT CONST COMMA COLON CHAR BUILTIN_VA_ARG BUILTIN_OFFSETOF BANG AUTO ATTRIBUTE AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## ALIGNAS LPAREN argument_expression_list
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 87, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
## In state 145, spurious reduction of production assignment_expression -> conditional_expression 
## In state 155, spurious reduction of production argument_expression_list -> assignment_expression 
##

# We are trying to recognize an alignas specifier.
# We have already recognized at least one argument_expression.
# We expect either "COMMA assignment_expression" or RPAREN.
# But, in CompCert, only one expression is allowed as part of ALIGNAS (see Elab.ml).
# So we say we expect RPAREN.

# And we say we have recognized "an expression", instead of "a list of expressions".
# Not sure whether this is a good idea.

# gcc, clang: like us, expect a closing parenthesis.

Ill-formed _Alignas qualifier.
Up to this point, an expression has been recognized:
  $0
If this expression is complete,
then at this point, a closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: ALIGNAS LPAREN INT LBRACK RPAREN
##
## Ends in an error in state: 248.
##
## direct_abstract_declarator -> option(direct_abstract_declarator) LBRACK option(type_qualifier_list) . optional(assignment_expression,RBRACK) [ RPAREN LPAREN LBRACK COMMA ]
## type_qualifier_list -> option(type_qualifier_list) . type_qualifier_noattr [ VOLATILE TILDE STRING_LITERAL STAR SIZEOF RESTRICT RBRACK PRE_NAME PLUS PACKED MINUS LPAREN INC DEC CONSTANT CONST BUILTIN_VA_ARG BUILTIN_OFFSETOF BANG ATTRIBUTE AND ALIGNOF ALIGNAS ]
## type_qualifier_list -> option(type_qualifier_list) . attribute_specifier [ VOLATILE TILDE STRING_LITERAL STAR SIZEOF RESTRICT RBRACK PRE_NAME PLUS PACKED MINUS LPAREN INC DEC CONSTANT CONST BUILTIN_VA_ARG BUILTIN_OFFSETOF BANG ATTRIBUTE AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## option(direct_abstract_declarator) LBRACK option(type_qualifier_list)
##
translation_unit_file: INT PRE_NAME VAR_NAME LBRACK RPAREN
##
## Ends in an error in state: 265.
##
## direct_declarator -> direct_declarator LBRACK option(type_qualifier_list) . optional(assignment_expression,RBRACK) [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG LBRACK LBRACE INT INLINE FLOAT EXTERN EQ ENUM DOUBLE CONST COMMA COLON CHAR AUTO ATTRIBUTE ALIGNAS ]
## type_qualifier_list -> option(type_qualifier_list) . type_qualifier_noattr [ VOLATILE TILDE STRING_LITERAL STAR SIZEOF RESTRICT RBRACK PRE_NAME PLUS PACKED MINUS LPAREN INC DEC CONSTANT CONST BUILTIN_VA_ARG BUILTIN_OFFSETOF BANG ATTRIBUTE AND ALIGNOF ALIGNAS ]
## type_qualifier_list -> option(type_qualifier_list) . attribute_specifier [ VOLATILE TILDE STRING_LITERAL STAR SIZEOF RESTRICT RBRACK PRE_NAME PLUS PACKED MINUS LPAREN INC DEC CONSTANT CONST BUILTIN_VA_ARG BUILTIN_OFFSETOF BANG ATTRIBUTE AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## direct_declarator LBRACK option(type_qualifier_list)
##

# We are trying to recognize an array declarator.
# We have seen the opening bracket and (maybe) some type qualifiers.
# We are expecting more type qualifiers, or an expression, or a closing bracket.

# gcc, clang: both say they expect an expression (and nothing else).
# Yet, they do accept a closing bracket.

# If in the first sentence we replace the invalid token with a type qualifier, such as CONST,
# gcc and clang both say:
# error: type qualifier used in array declarator outside of function prototype
# On the other hand, in the second sentence, they accept a qualifier.

# We choose not to mention the possibility of a type qualifier (which may be
# illegal here anyway).

Ill-formed array declarator.
At this point, one of the following is expected:
  an expression, followed with a closing bracket ']'; or
  a closing bracket ']'.

# ------------------------------------------------------------------------------

translation_unit_file: ALIGNAS LPAREN INT LPAREN INT COMMA ELLIPSIS XOR_ASSIGN
##
## Ends in an error in state: 276.
##
## direct_abstract_declarator -> LPAREN option(context_parameter_type_list) . RPAREN [ RPAREN LPAREN LBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## LPAREN option(context_parameter_type_list)
##
translation_unit_file: ALIGNAS LPAREN INT LBRACK RBRACK LPAREN INT COMMA ELLIPSIS XOR_ASSIGN
##
## Ends in an error in state: 259.
##
## direct_abstract_declarator -> direct_abstract_declarator LPAREN option(context_parameter_type_list) . RPAREN [ RPAREN LPAREN LBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## direct_abstract_declarator LPAREN option(context_parameter_type_list)
##
translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT COMMA ELLIPSIS XOR_ASSIGN
##
## Ends in an error in state: 293.
##
## direct_declarator -> direct_declarator LPAREN context_parameter_type_list . RPAREN [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG LBRACK LBRACE INT INLINE FLOAT EXTERN EQ ENUM DOUBLE CONST COMMA COLON CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## direct_declarator LPAREN context_parameter_type_list
##

# Unlikely error, since only the ELLIPSIS allows us to tell that
# the parameter list is finished.

At this point, a closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: ALIGNAS LPAREN INT LPAREN LPAREN RPAREN COMMA
##
## Ends in an error in state: 274.
##
## direct_abstract_declarator -> LPAREN save_context abstract_declarator(type_name) . RPAREN [ RPAREN LPAREN LBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## LPAREN save_context abstract_declarator(type_name)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 267, spurious reduction of production abstract_declarator(type_name) -> direct_abstract_declarator 
##
#
# The first LPAREN in this example must be the beginning of an abstract_declarator.
# It leads us into a state where we do not yet know the meaning of the opening parenthesis:
#   direct_abstract_declarator -> LPAREN . abstract_declarator RPAREN [ RPAREN LPAREN LBRACK ]
#   direct_abstract_declarator -> LPAREN . in_context(option(parameter_type_list)) RPAREN [ RPAREN LPAREN LBRACK ]
# i.e. (a) this could be the opening parenthesis in a pair of parentheses,
#   or (d) this could be the opening parenthesis in a function type.
# The second LPAREN takes us again into the same state.
# The RPAREN allows us to recognize that we have a function type of no parameters (d).
# Hence, LPAREN RPAREN forms a direct_abstract_declarator.
# At this point, the status of the first LPAREN is still undetermined (regular paren,
# or beginning of a function type?) but that is not a problem for us.
#
# This case is simplified by giving a phantom context parameter to abstract_declarator.
# Here, we know we are in the context of a type_name or direct_abstract_declarator,
# so RPAREN is allowed next.
# If we were in the context of a parameter_declaration, COMMA would be allowed next.
#

# gcc and clang simply request a closing parenthesis.

Up to this point, an abstract declarator has been recognized:
  $0
At this point, a closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: ALIGNAS LPAREN INT LPAREN XOR_ASSIGN
##
## Ends in an error in state: 315.
##
## direct_abstract_declarator -> LPAREN . save_context abstract_declarator(type_name) RPAREN [ RPAREN LPAREN LBRACK COMMA ]
## direct_abstract_declarator -> LPAREN . option(context_parameter_type_list) RPAREN [ RPAREN LPAREN LBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

# gcc and clang both say they want a closing parenthesis.
# This seems a bit extreme.

An opening parenthesis '(' has been recognized.
At this point, one of the following is expected:
  an abstract declarator,
    if this parenthesis is a delimiter; or
  a list of parameter declarations,
    if this parenthesis is the beginning of a function declarator.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT LPAREN XOR_ASSIGN
##
## Ends in an error in state: 242.
##
## direct_abstract_declarator -> LPAREN . save_context abstract_declarator(type_name) RPAREN [ RPAREN LPAREN LBRACK COMMA ]
## direct_abstract_declarator -> LPAREN . option(context_parameter_type_list) RPAREN [ RPAREN LPAREN LBRACK COMMA ]
## direct_declarator -> LPAREN . save_context declarator RPAREN [ RPAREN PACKED LPAREN LBRACK COMMA ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

# Analogous to the above, but has a third item.

An opening parenthesis '(' has been recognized.
At this point, one of the following is expected:
  an abstract declarator or a declarator,
    if this parenthesis is a delimiter; or
  a list of parameter declarations,
    if this parenthesis is the beginning of a function declarator.

# ------------------------------------------------------------------------------

translation_unit_file: ALIGNAS LPAREN VOLATILE ADD_ASSIGN
##
## Ends in an error in state: 307.
##
## option(type_qualifier_list) -> type_qualifier_list . [ VOLATILE RESTRICT PACKED CONST ATTRIBUTE ALIGNAS ]
## specifier_qualifier_list(type_name) -> type_qualifier_list . typedef_name option(type_qualifier_list) [ STAR RPAREN LPAREN LBRACK COMMA ]
## specifier_qualifier_list(type_name) -> type_qualifier_list . type_specifier_no_typedef_name list(specifier_qualifier_no_typedef_name) [ STAR RPAREN LPAREN LBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## type_qualifier_list
##

# We are trying to recognize a specifier-qualifier-list, and have not yet seen
# a type specifier, which is why we know the list is not finished.

# clang says it expects a type.
# gcc says the missing type defaults to int, and expects a closing parenthesis.

Ill-formed type name.
At this point, one of the following is expected:
  a type qualifier; or
  a type specifier.

# ------------------------------------------------------------------------------

translation_unit_file: ALIGNAS LPAREN XOR_ASSIGN
##
## Ends in an error in state: 61.
##
## attribute_specifier -> ALIGNAS LPAREN . argument_expression_list RPAREN [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE STRUCT STRING_LITERAL STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER RBRACK PRE_NAME PLUS PACKED NORETURN MINUS LPAREN LONG LBRACK LBRACE INT INLINE INC FLOAT EXTERN EQ ENUM DOUBLE DEC CONSTANT CONST COMMA COLON CHAR BUILTIN_VA_ARG BUILTIN_OFFSETOF BANG AUTO ATTRIBUTE AND ALIGNOF ALIGNAS ]
## attribute_specifier -> ALIGNAS LPAREN . type_name RPAREN [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE STRUCT STRING_LITERAL STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER RBRACK PRE_NAME PLUS PACKED NORETURN MINUS LPAREN LONG LBRACK LBRACE INT INLINE INC FLOAT EXTERN EQ ENUM DOUBLE DEC CONSTANT CONST COMMA COLON CHAR BUILTIN_VA_ARG BUILTIN_OFFSETOF BANG AUTO ATTRIBUTE AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## ALIGNAS LPAREN
##

# This one seems easy. We have recognized ALIGNAS LPAREN, and nothing that makes sense beyond that.

# clang and gcc say they expect an expression.

Ill-formed _Alignas qualifier.
At this point, one of the following is expected:
  an expression; or
  a type name.

# ------------------------------------------------------------------------------

translation_unit_file: ALIGNAS XOR_ASSIGN
##
## Ends in an error in state: 60.
##
## attribute_specifier -> ALIGNAS . LPAREN argument_expression_list RPAREN [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE STRUCT STRING_LITERAL STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER RBRACK PRE_NAME PLUS PACKED NORETURN MINUS LPAREN LONG LBRACK LBRACE INT INLINE INC FLOAT EXTERN EQ ENUM DOUBLE DEC CONSTANT CONST COMMA COLON CHAR BUILTIN_VA_ARG BUILTIN_OFFSETOF BANG AUTO ATTRIBUTE AND ALIGNOF ALIGNAS ]
## attribute_specifier -> ALIGNAS . LPAREN type_name RPAREN [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE STRUCT STRING_LITERAL STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER RBRACK PRE_NAME PLUS PACKED NORETURN MINUS LPAREN LONG LBRACK LBRACE INT INLINE INC FLOAT EXTERN EQ ENUM DOUBLE DEC CONSTANT CONST COMMA COLON CHAR BUILTIN_VA_ARG BUILTIN_OFFSETOF BANG AUTO ATTRIBUTE AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## ALIGNAS
##

# Fingers in the nose.

Ill-formed _Alignas qualifier.
At this point, an opening parenthesis '(' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: ATTRIBUTE LPAREN LPAREN COMMA XOR_ASSIGN
##
## Ends in an error in state: 353.
##
## gcc_attribute_list -> gcc_attribute_list COMMA . gcc_attribute [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## gcc_attribute_list COMMA
##

# We are expecting a gcc_attribute. This symbol is nullable, so
# RPAREN and COMMA are permitted too, but we can ignore this
# possibility in the error message (why would someone use an
# empty attribute?).

# clang and gcc say they expect a closing parenthesis.

Ill-formed attribute specifier.
At this point, a gcc attribute is expected.

# ------------------------------------------------------------------------------

translation_unit_file: ATTRIBUTE LPAREN LPAREN RPAREN XOR_ASSIGN
##
## Ends in an error in state: 351.
##
## attribute_specifier -> ATTRIBUTE LPAREN LPAREN gcc_attribute_list RPAREN . RPAREN [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE STRUCT STRING_LITERAL STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER RBRACK PRE_NAME PLUS PACKED NORETURN MINUS LPAREN LONG LBRACK LBRACE INT INLINE INC FLOAT EXTERN EQ ENUM DOUBLE DEC CONSTANT CONST COMMA COLON CHAR BUILTIN_VA_ARG BUILTIN_OFFSETOF BANG AUTO ATTRIBUTE AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## ATTRIBUTE LPAREN LPAREN gcc_attribute_list RPAREN
##

Ill-formed attribute specifier.
At this point, a second closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: ATTRIBUTE LPAREN LPAREN PRE_NAME VAR_NAME LPAREN RPAREN XOR_ASSIGN
##
## Ends in an error in state: 350.
##
## attribute_specifier -> ATTRIBUTE LPAREN LPAREN gcc_attribute_list . RPAREN RPAREN [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE STRUCT STRING_LITERAL STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER RBRACK PRE_NAME PLUS PACKED NORETURN MINUS LPAREN LONG LBRACK LBRACE INT INLINE INC FLOAT EXTERN EQ ENUM DOUBLE DEC CONSTANT CONST COMMA COLON CHAR BUILTIN_VA_ARG BUILTIN_OFFSETOF BANG AUTO ATTRIBUTE AND ALIGNOF ALIGNAS ]
## gcc_attribute_list -> gcc_attribute_list . COMMA gcc_attribute [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## ATTRIBUTE LPAREN LPAREN gcc_attribute_list
##

# We have a seen a (non-empty) attribute list, so we expect either
# a COMMA or a closing LPAREN LPAREN.

# gcc/clang say they expect a closing parenthesis.

Ill-formed attribute specifier.
At this point, one of the following is expected:
  a comma ',', followed with a gcc attribute; or
  two closing parentheses '))'.

# ------------------------------------------------------------------------------

translation_unit_file: ATTRIBUTE LPAREN LPAREN PRE_NAME VAR_NAME LPAREN PRE_NAME TYPEDEF_NAME COMMA PRE_NAME VAR_NAME SEMICOLON
##
## Ends in an error in state: 346.
##
## argument_expression_list -> argument_expression_list . COMMA assignment_expression [ RPAREN COMMA ]
## gcc_attribute -> gcc_attribute_word LPAREN typedef_name COMMA argument_expression_list . RPAREN [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## gcc_attribute_word LPAREN typedef_name COMMA argument_expression_list
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 87, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
## In state 145, spurious reduction of production assignment_expression -> conditional_expression 
## In state 155, spurious reduction of production argument_expression_list -> assignment_expression 
##

# We know for sure that we are parsing a gcc attribute.
# A (non-empty) list of expressions has been read.

# gcc/clang say they want a closing parenthesis.

Ill-formed gcc attribute.
Up to this point, a list of expressions has been recognized:
  $0
If this list is complete,
then at this point, a closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: ATTRIBUTE LPAREN LPAREN PRE_NAME VAR_NAME LPAREN PRE_NAME TYPEDEF_NAME COMMA XOR_ASSIGN
##
## Ends in an error in state: 345.
##
## gcc_attribute -> gcc_attribute_word LPAREN typedef_name COMMA . argument_expression_list RPAREN [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## gcc_attribute_word LPAREN typedef_name COMMA
##

# gcc/clang agree.

Ill-formed gcc attribute.
At this point, an expression is expected.

# ------------------------------------------------------------------------------

translation_unit_file: ATTRIBUTE LPAREN LPAREN PRE_NAME VAR_NAME LPAREN PRE_NAME TYPEDEF_NAME XOR_ASSIGN
##
## Ends in an error in state: 344.
##
## gcc_attribute -> gcc_attribute_word LPAREN typedef_name . COMMA argument_expression_list RPAREN [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## gcc_attribute_word LPAREN typedef_name
##

# gcc and clang complain about the TYPEDEF_NAME, not sure why.

Ill-formed gcc attribute.
At this point, a comma ',' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: ATTRIBUTE LPAREN LPAREN PRE_NAME VAR_NAME LPAREN XOR_ASSIGN
##
## Ends in an error in state: 47.
##
## gcc_attribute -> gcc_attribute_word LPAREN . option(argument_expression_list) RPAREN [ RPAREN COMMA ]
## gcc_attribute -> gcc_attribute_word LPAREN . typedef_name COMMA argument_expression_list RPAREN [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## gcc_attribute_word LPAREN
##

# gcc and clang just say they expect an expression.
# There is kind of hack in the pre_parser, here.
# Without going into the details, we should just say we expect a list of attribute arguments.

Ill-formed gcc attribute.
At this point, a list of expressions is expected.

# ------------------------------------------------------------------------------

translation_unit_file: ATTRIBUTE LPAREN LPAREN PRE_NAME VAR_NAME XOR_ASSIGN
##
## Ends in an error in state: 46.
##
## gcc_attribute -> gcc_attribute_word . [ RPAREN COMMA ]
## gcc_attribute -> gcc_attribute_word . LPAREN option(argument_expression_list) RPAREN [ RPAREN COMMA ]
## gcc_attribute -> gcc_attribute_word . LPAREN typedef_name COMMA argument_expression_list RPAREN [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## gcc_attribute_word
##

# gcc and clang say they expect a closing parenthesis (as usual).

Ill-formed gcc attribute specifier.
Up to this point, an attribute has been recognized:
  $0
At this point, one of the following is expected:
  an opening parenthesis '(',
    followed with a list of parameters for this attribute; or
  a comma ',',
    followed with another attribute; or
  a closing parenthesis ')'.

# ------------------------------------------------------------------------------

translation_unit_file: ATTRIBUTE LPAREN LPAREN XOR_ASSIGN
##
## Ends in an error in state: 39.
##
## attribute_specifier -> ATTRIBUTE LPAREN LPAREN . gcc_attribute_list RPAREN RPAREN [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE STRUCT STRING_LITERAL STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER RBRACK PRE_NAME PLUS PACKED NORETURN MINUS LPAREN LONG LBRACK LBRACE INT INLINE INC FLOAT EXTERN EQ ENUM DOUBLE DEC CONSTANT CONST COMMA COLON CHAR BUILTIN_VA_ARG BUILTIN_OFFSETOF BANG AUTO ATTRIBUTE AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## ATTRIBUTE LPAREN LPAREN
##

# A non-empty attribute list is expected.
# Hence, an attribute is expected.
# (The gcc documentation says a list of attributes can be empty, but
# since an attribute can be empty too, this creates a conflict.)

# clang and gcc want a closing parenthesis, as usual (sigh)...

Ill-formed gcc attribute specifier.
At this point, a gcc attribute is expected.

# ------------------------------------------------------------------------------

translation_unit_file: ATTRIBUTE LPAREN XOR_ASSIGN
##
## Ends in an error in state: 38.
##
## attribute_specifier -> ATTRIBUTE LPAREN . LPAREN gcc_attribute_list RPAREN RPAREN [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE STRUCT STRING_LITERAL STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER RBRACK PRE_NAME PLUS PACKED NORETURN MINUS LPAREN LONG LBRACK LBRACE INT INLINE INC FLOAT EXTERN EQ ENUM DOUBLE DEC CONSTANT CONST COMMA COLON CHAR BUILTIN_VA_ARG BUILTIN_OFFSETOF BANG AUTO ATTRIBUTE AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## ATTRIBUTE LPAREN
##

Ill-formed gcc attribute specifier.
At this point, a second opening parenthesis '(' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: ATTRIBUTE XOR_ASSIGN
##
## Ends in an error in state: 37.
##
## attribute_specifier -> ATTRIBUTE . LPAREN LPAREN gcc_attribute_list RPAREN RPAREN [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE STRUCT STRING_LITERAL STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER RBRACK PRE_NAME PLUS PACKED NORETURN MINUS LPAREN LONG LBRACK LBRACE INT INLINE INC FLOAT EXTERN EQ ENUM DOUBLE DEC CONSTANT CONST COMMA COLON CHAR BUILTIN_VA_ARG BUILTIN_OFFSETOF BANG AUTO ATTRIBUTE AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## ATTRIBUTE
##

Ill-formed gcc attribute specifier.
At this point, two opening parentheses '((' are expected.

# ------------------------------------------------------------------------------

translation_unit_file: ENUM LBRACE PRE_NAME VAR_NAME COMMA XOR_ASSIGN
##
## Ends in an error in state: 361.
##
## enumerator_list -> enumerator_list COMMA . declare_varname(enumerator) [ RBRACE COMMA ]
## option(COMMA) -> COMMA . [ RBRACE ]
##
## The known suffix of the stack is as follows:
## enumerator_list COMMA
##

# We omit the possibility of a closing brace.

# gcc and clang say they want an identifier.
# Indeed, an enumerator must begin with an identifier.

Ill-formed enumeration specifier.
At this point, an enumerator is expected.

# ------------------------------------------------------------------------------

translation_unit_file: ENUM LBRACE PRE_NAME VAR_NAME EQ CONSTANT SEMICOLON
##
## Ends in an error in state: 360.
##
## enum_specifier -> ENUM attribute_specifier_list option(other_identifier) LBRACE enumerator_list . option(COMMA) RBRACE [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF STRUCT STATIC STAR SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG LBRACK INT INLINE FLOAT EXTERN ENUM DOUBLE CONST COMMA COLON CHAR AUTO ATTRIBUTE ALIGNAS ]
## enumerator_list -> enumerator_list . COMMA declare_varname(enumerator) [ RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## ENUM attribute_specifier_list option(other_identifier) LBRACE enumerator_list
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 79, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
## In state 365, spurious reduction of production enumerator -> enumeration_constant EQ conditional_expression 
## In state 362, spurious reduction of production declare_varname(enumerator) -> enumerator 
## In state 369, spurious reduction of production enumerator_list -> declare_varname(enumerator) 
##
#
# At first sight, it seems that the last enumerator that we have recognized
# could be of the form either "enumeration_constant" or
# "enumeration_constant EQ constant_expression".
#
# However, a moment's thought reveals that it cannot be of the first form,
# otherwise the syntax error would have been detected in this state:
#   enumerator -> enumeration_constant . [ RBRACE COMMA ]
#   enumerator -> enumeration_constant . EQ constant_expression [ RBRACE COMMA ]
# To see this, try the sentence ENUM LBRACE VAR_NAME XOR_ASSIGN.
#
# So, the last enumerator must be of the second form, which means it would be safe
# for us to say "an expression has just been recognized".
#
# On the other hand, we cannot show the expression that has just been recognized;
# we can only show the enumerator list $0.
#
# We omit the fact that a comma is allowed just before the closing brace.

Ill-formed enumeration specifier.
Up to this point, a list of enumerators has been recognized:
  $0
If this list is complete,
then at this point, a closing brace '}' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: ENUM LBRACE PRE_NAME VAR_NAME EQ XOR_ASSIGN
##
## Ends in an error in state: 364.
##
## enumerator -> enumeration_constant EQ . conditional_expression [ RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## enumeration_constant EQ
##

Ill-formed enumeration specifier.
At this point, a constant expression is expected.

# ------------------------------------------------------------------------------

translation_unit_file: ENUM LBRACE PRE_NAME VAR_NAME XOR_ASSIGN
##
## Ends in an error in state: 363.
##
## enumerator -> enumeration_constant . [ RBRACE COMMA ]
## enumerator -> enumeration_constant . EQ conditional_expression [ RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## enumeration_constant
##

# Here, both clang and gcc give an incomplete diagnostic message.

Ill-formed enumeration specifier.
At this point, one of the following is expected:
  an equals sign '=', followed with a constant expression; or
  a comma ',', followed with an enumerator; or
  a closing brace '}'.

# ------------------------------------------------------------------------------

translation_unit_file: ENUM LBRACE XOR_ASSIGN
##
## Ends in an error in state: 358.
##
## enum_specifier -> ENUM attribute_specifier_list option(other_identifier) LBRACE . enumerator_list option(COMMA) RBRACE [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF STRUCT STATIC STAR SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG LBRACK INT INLINE FLOAT EXTERN ENUM DOUBLE CONST COMMA COLON CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## ENUM attribute_specifier_list option(other_identifier) LBRACE
##

# gcc says it expects an identifier.
# clang says it expects a closing brace (which seems incorrect).

Ill-formed enumeration specifier.
At this point, an enumerator is expected.

# ------------------------------------------------------------------------------

translation_unit_file: ENUM XOR_ASSIGN
##
## Ends in an error in state: 356.
##
## enum_specifier -> ENUM attribute_specifier_list . option(other_identifier) LBRACE enumerator_list option(COMMA) RBRACE [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF STRUCT STATIC STAR SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG LBRACK INT INLINE FLOAT EXTERN ENUM DOUBLE CONST COMMA COLON CHAR AUTO ATTRIBUTE ALIGNAS ]
## enum_specifier -> ENUM attribute_specifier_list . general_identifier [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF STRUCT STATIC STAR SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG LBRACK INT INLINE FLOAT EXTERN ENUM DOUBLE CONST COMMA COLON CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## ENUM attribute_specifier_list
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production attribute_specifier_list -> 
##

# Here, both clang and gcc give an incomplete diagnostic message.

Ill-formed enumeration specifier.
At this point, one of the following is expected:
  an attribute specifier; or
  an identifier; or
  an opening brace '{'.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ ALIGNOF LPAREN XOR_ASSIGN
##
## Ends in an error in state: 65.
##
## unary_expression -> ALIGNOF LPAREN . type_name RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LEQ LEFT_ASSIGN LEFT HAT GT GEQ EQEQ EQ DIV_ASSIGN COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## ALIGNOF LPAREN
##
translation_unit_file: INT PRE_NAME VAR_NAME EQ SIZEOF LPAREN XOR_ASSIGN
##
## Ends in an error in state: 28.
##
## postfix_expression -> LPAREN . type_name RPAREN LBRACE initializer_list option(COMMA) RBRACE [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
## primary_expression -> LPAREN . expression RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
## unary_expression -> SIZEOF LPAREN . type_name RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LEQ LEFT_ASSIGN LEFT HAT GT GEQ EQEQ EQ DIV_ASSIGN COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## SIZEOF LPAREN
##

# Tricky because we could be looking at the beginning of a compound
# literal, in which case we expect a type name! But that would be a
# use of SIZEOF or ALIGNOF without parentheses, which is very unlikely.
# So, we omit this possibility.

# gcc/clang do the same.

Ill-formed use of $1.
At this point, an expression is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ ALIGNOF XOR_ASSIGN
##
## Ends in an error in state: 64.
##
## unary_expression -> ALIGNOF . LPAREN type_name RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LEQ LEFT_ASSIGN LEFT HAT GT GEQ EQEQ EQ DIV_ASSIGN COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## ALIGNOF
##

Ill-formed use of $0.
At this point, an opening parenthesis '(' is expected,
followed with a type name.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ SIZEOF XOR_ASSIGN
##
## Ends in an error in state: 23.
##
## unary_expression -> SIZEOF . unary_expression [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LEQ LEFT_ASSIGN LEFT HAT GT GEQ EQEQ EQ DIV_ASSIGN COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
## unary_expression -> SIZEOF . LPAREN type_name RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LEQ LEFT_ASSIGN LEFT HAT GT GEQ EQEQ EQ DIV_ASSIGN COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## SIZEOF
##

# Let's not reveal that sizeof can be used without parentheses.

# gcc and clang say they expect an expression, which seems both surprising
# (they don't request a parenthesis) and incomplete (they don't allow a type name).

Ill-formed use of $0.
At this point, an opening parenthesis '(' is expected,
followed with an expression or a type name.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ BUILTIN_VA_ARG LPAREN PRE_NAME VAR_NAME SEMICOLON
##
## Ends in an error in state: 339.
##
## postfix_expression -> BUILTIN_VA_ARG LPAREN assignment_expression . COMMA type_name RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## BUILTIN_VA_ARG LPAREN assignment_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 87, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
## In state 145, spurious reduction of production assignment_expression -> conditional_expression 
##

Ill-formed use of $2.
Up to this point, an expression has been recognized:
  $0
If this expression is complete,
then at this point, a comma ',' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ BUILTIN_VA_ARG LPAREN PRE_NAME VAR_NAME COMMA XOR_ASSIGN
##
## Ends in an error in state: 340.
##
## postfix_expression -> BUILTIN_VA_ARG LPAREN assignment_expression COMMA . type_name RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## BUILTIN_VA_ARG LPAREN assignment_expression COMMA
##

Ill-formed use of $3.
At this point, a type name is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ BUILTIN_VA_ARG LPAREN XOR_ASSIGN
##
## Ends in an error in state: 51.
##
## postfix_expression -> BUILTIN_VA_ARG LPAREN . assignment_expression COMMA type_name RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## BUILTIN_VA_ARG LPAREN
##

Ill-formed use of $1.
At this point, an expression is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ BUILTIN_VA_ARG XOR_ASSIGN
##
## Ends in an error in state: 50.
##
## postfix_expression -> BUILTIN_VA_ARG . LPAREN assignment_expression COMMA type_name RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## BUILTIN_VA_ARG
##

Ill-formed use of $0.
At this point, an opening parenthesis '(' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ DEC XOR_ASSIGN
##
## Ends in an error in state: 48.
##
## unary_expression -> DEC . unary_expression [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LEQ LEFT_ASSIGN LEFT HAT GT GEQ EQEQ EQ DIV_ASSIGN COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## DEC
##
translation_unit_file: INT PRE_NAME VAR_NAME EQ INC XOR_ASSIGN
##
## Ends in an error in state: 33.
##
## unary_expression -> INC . unary_expression [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LEQ LEFT_ASSIGN LEFT HAT GT GEQ EQEQ EQ DIV_ASSIGN COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## INC
##

Ill-formed expression.
At this point, an expression is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ INC LPAREN INT RPAREN XOR_ASSIGN
##
## Ends in an error in state: 372.
##
## postfix_expression -> LPAREN type_name RPAREN . LBRACE initializer_list option(COMMA) RBRACE [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## LPAREN type_name RPAREN
##

# Here, we seem to be certain that this must be the beginning of a
# compound literal, so an opening brace is expected.
# However, it is quite likely that the user does not even know about
# compound literals, so the error took place earlier.
# Maybe the user intended to write a cast expression, and he forgot
# to open one more parenthesis before the one we see here.
# Or maybe the name that we classified as a type was intended to be a variable.

# gcc says an expression is expected, which seems incorrect.
# clang says "expected '{' in compound literal".

Ill-formed expression.
Up to this point, a type name in parentheses has been recognized:
  $2 $1 $0
If this is the beginning of a compound literal,
  then at this point, an opening brace '{' is expected.
If this is intended to be the beginning of a cast expression,
  then perhaps an opening parenthesis '(' was forgotten earlier.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ INC LPAREN XOR_ASSIGN
##
## Ends in an error in state: 34.
##
## postfix_expression -> LPAREN . type_name RPAREN LBRACE initializer_list option(COMMA) RBRACE [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
## primary_expression -> LPAREN . expression RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

# gcc and clang expect an expression.
# We could choose to omit the first possibility, too.

Ill-formed expression.
At this point, one of the following is expected:
  a type name (if this is the beginning of a compound literal); or
  an expression.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ LPAREN PRE_NAME VAR_NAME SEMICOLON
##
## Ends in an error in state: 390.
##
## expression -> expression . COMMA assignment_expression [ RPAREN COMMA ]
## primary_expression -> LPAREN expression . RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## LPAREN expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 87, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
## In state 145, spurious reduction of production assignment_expression -> conditional_expression 
## In state 149, spurious reduction of production expression -> assignment_expression 
##

# Since we are saying "if this expression is complete",
# there seems to be no need to say that this expression
# can be continued with a comma and another expression.
# So, let's just say a closing parenthesis is expected.

Ill-formed expression.
Up to this point, an expression has been recognized:
  $0
If this expression is complete,
then at this point, a closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ LPAREN INT RPAREN LBRACE PRE_NAME VAR_NAME SEMICOLON
##
## Ends in an error in state: 387.
##
## initializer_list -> initializer_list . COMMA option(designation) c_initializer [ RBRACE COMMA ]
## postfix_expression -> LPAREN type_name RPAREN LBRACE initializer_list . option(COMMA) RBRACE [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## LPAREN type_name RPAREN LBRACE initializer_list
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 87, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
## In state 145, spurious reduction of production assignment_expression -> conditional_expression 
## In state 380, spurious reduction of production c_initializer -> assignment_expression 
## In state 386, spurious reduction of production initializer_list -> option(designation) c_initializer 
##

# Let's ignore the fact that a comma can precede a closing brace.

Ill-formed compound literal.
Up to this point, a list of initializers has been recognized:
  $0
If this list is complete,
then at this point, a closing brace '}' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ LPAREN INT RPAREN LBRACE XOR_ASSIGN
##
## Ends in an error in state: 373.
##
## postfix_expression -> LPAREN type_name RPAREN LBRACE . initializer_list option(COMMA) RBRACE [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## LPAREN type_name RPAREN LBRACE
##

# gcc and clang say an expression is expected, which is incomplete.

Ill-formed compound literal.
At this point, an initializer is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ LPAREN INT RPAREN XOR_ASSIGN
##
## Ends in an error in state: 394.
##
## cast_expression -> LPAREN type_name RPAREN . cast_expression [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LEQ LEFT_ASSIGN LEFT HAT GT GEQ EQEQ EQ DIV_ASSIGN COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
## postfix_expression -> LPAREN type_name RPAREN . LBRACE initializer_list option(COMMA) RBRACE [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## LPAREN type_name RPAREN
##

# clang and gcc expect an expression.

Ill-formed expression.
Up to this point, a type name in parentheses has been recognized:
  $2 $1 $0
At this point, one of the following is expected:
  an expression,        if this is a type cast; or
  an opening brace '{', if this is a compound literal.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ LPAREN XOR_ASSIGN
##
## Ends in an error in state: 30.
##
## cast_expression -> LPAREN . type_name RPAREN cast_expression [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LEQ LEFT_ASSIGN LEFT HAT GT GEQ EQEQ EQ DIV_ASSIGN COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
## postfix_expression -> LPAREN . type_name RPAREN LBRACE initializer_list option(COMMA) RBRACE [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
## primary_expression -> LPAREN . expression RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

# clang and gcc expect an expression.

Ill-formed expression.
An opening parenthesis '(' has just been recognized.
At this point, one of the following is expected:
  a type name,   if this is a type cast or a compound literal; or
  an expression, if this is a parenthesized expression.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ TILDE XOR_ASSIGN
##
## Ends in an error in state: 78.
##
## unary_expression -> unary_operator . cast_expression [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LEQ LEFT_ASSIGN LEFT HAT GT GEQ EQEQ EQ DIV_ASSIGN COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## unary_operator
##

# clang and gcc expect an expression.

Ill-formed use of the unary operator $0.
At this point, an expression is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME VAR_NAME AND XOR_ASSIGN
##
## Ends in an error in state: 138.
##
## and_expression -> and_expression AND . equality_expression [ SEMICOLON RPAREN RBRACK RBRACE QUESTION HAT COMMA COLON BARBAR BAR ANDAND AND ]
##
## The known suffix of the stack is as follows:
## and_expression AND
##
translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME VAR_NAME ANDAND XOR_ASSIGN
##
## Ends in an error in state: 127.
##
## logical_and_expression -> logical_and_expression ANDAND . inclusive_or_expression [ SEMICOLON RPAREN RBRACK RBRACE QUESTION COMMA COLON BARBAR ANDAND ]
##
## The known suffix of the stack is as follows:
## logical_and_expression ANDAND
##
translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME VAR_NAME BAR XOR_ASSIGN
##
## Ends in an error in state: 129.
##
## inclusive_or_expression -> inclusive_or_expression BAR . exclusive_or_expression [ SEMICOLON RPAREN RBRACK RBRACE QUESTION COMMA COLON BARBAR BAR ANDAND ]
##
## The known suffix of the stack is as follows:
## inclusive_or_expression BAR
##
translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME VAR_NAME BARBAR XOR_ASSIGN
##
## Ends in an error in state: 150.
##
## logical_or_expression -> logical_or_expression BARBAR . logical_and_expression [ SEMICOLON RPAREN RBRACK RBRACE QUESTION COMMA COLON BARBAR ]
##
## The known suffix of the stack is as follows:
## logical_or_expression BARBAR
##
translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME VAR_NAME HAT XOR_ASSIGN
##
## Ends in an error in state: 131.
##
## exclusive_or_expression -> exclusive_or_expression HAT . and_expression [ SEMICOLON RPAREN RBRACK RBRACE QUESTION HAT COMMA COLON BARBAR BAR ANDAND ]
##
## The known suffix of the stack is as follows:
## exclusive_or_expression HAT
##
translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME VAR_NAME LT XOR_ASSIGN
##
## Ends in an error in state: 121.
##
## relational_expression -> relational_expression relational_operator . shift_expression [ SEMICOLON RPAREN RBRACK RBRACE QUESTION NEQ LT LEQ HAT GT GEQ EQEQ COMMA COLON BARBAR BAR ANDAND AND ]
##
## The known suffix of the stack is as follows:
## relational_expression relational_operator
##
translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME VAR_NAME NEQ XOR_ASSIGN
##
## Ends in an error in state: 135.
##
## equality_expression -> equality_expression equality_operator . relational_expression [ SEMICOLON RPAREN RBRACK RBRACE QUESTION NEQ HAT EQEQ COMMA COLON BARBAR BAR ANDAND AND ]
##
## The known suffix of the stack is as follows:
## equality_expression equality_operator
##
translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME VAR_NAME PLUS XOR_ASSIGN
##
## Ends in an error in state: 114.
##
## additive_expression -> additive_expression additive_operator . multiplicative_expression [ SEMICOLON RPAREN RIGHT RBRACK RBRACE QUESTION PLUS NEQ MINUS LT LEQ LEFT HAT GT GEQ EQEQ COMMA COLON BARBAR BAR ANDAND AND ]
##
## The known suffix of the stack is as follows:
## additive_expression additive_operator
##
translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME VAR_NAME RIGHT XOR_ASSIGN
##
## Ends in an error in state: 103.
##
## shift_expression -> shift_expression shift_operator . additive_expression [ SEMICOLON RPAREN RIGHT RBRACK RBRACE QUESTION NEQ LT LEQ LEFT HAT GT GEQ EQEQ COMMA COLON BARBAR BAR ANDAND AND ]
##
## The known suffix of the stack is as follows:
## shift_expression shift_operator
##
translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME VAR_NAME STAR XOR_ASSIGN
##
## Ends in an error in state: 108.
##
## multiplicative_expression -> multiplicative_expression multiplicative_operator . cast_expression [ STAR SLASH SEMICOLON RPAREN RIGHT RBRACK RBRACE QUESTION PLUS PERCENT NEQ MINUS LT LEQ LEFT HAT GT GEQ EQEQ COMMA COLON BARBAR BAR ANDAND AND ]
##
## The known suffix of the stack is as follows:
## multiplicative_expression multiplicative_operator
##

# clang and gcc expect an expression.

Ill-formed use of the binary operator $0.
At this point, an expression is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME VAR_NAME XOR_ASSIGN XOR_ASSIGN
##
## Ends in an error in state: 99.
##
## assignment_expression -> unary_expression assignment_operator . assignment_expression [ SEMICOLON RPAREN RBRACK RBRACE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## unary_expression assignment_operator
##

# clang and gcc expect an expression.

Ill-formed use of the assignment operator $0.
At this point, an expression is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME VAR_NAME LPAREN PRE_NAME VAR_NAME COMMA XOR_ASSIGN
##
## Ends in an error in state: 157.
##
## argument_expression_list -> argument_expression_list COMMA . assignment_expression [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## argument_expression_list COMMA
##

# Here, we could say more about the context if we parameterized
# argument_expression_list with a context. For the moment, let
# us just say that an expression is expected at this point.

# clang and gcc expect an expression.

Ill-formed list of expressions.
At this point, an expression is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME VAR_NAME DOT XOR_ASSIGN
##
## Ends in an error in state: 163.
##
## postfix_expression -> postfix_expression DOT . general_identifier [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## postfix_expression DOT
##
translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME VAR_NAME PTR XOR_ASSIGN
##
## Ends in an error in state: 84.
##
## postfix_expression -> postfix_expression PTR . general_identifier [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## postfix_expression PTR
##

# clang and gcc expect an identifier.

Ill-formed use of the dereferencing operator $0.
At this point, the name of a struct or union member is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME VAR_NAME LBRACK PRE_NAME VAR_NAME SEMICOLON
##
## Ends in an error in state: 160.
##
## expression -> expression . COMMA assignment_expression [ RBRACK COMMA ]
## postfix_expression -> postfix_expression LBRACK expression . RBRACK [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## postfix_expression LBRACK expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 87, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
## In state 145, spurious reduction of production assignment_expression -> conditional_expression 
## In state 149, spurious reduction of production expression -> assignment_expression 
##

# We know for sure that an array subscript expression has begun, and
# a closing bracket is expected (if the expression is complete).
# The expression could also be completed with a COMMA, but there is
# no reason to mention that -- it can be viewed as part of the
# hypothesis "if the expression is complete".

Ill-formed expression.
Up to this point, an expression has been recognized:
  $0
If this expression is complete,
then at this point, a closing bracket ']' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME VAR_NAME LBRACK XOR_ASSIGN
##
## Ends in an error in state: 159.
##
## postfix_expression -> postfix_expression LBRACK . expression RBRACK [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## postfix_expression LBRACK
##

Ill-formed expression.
At this point, an expression is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME VAR_NAME LPAREN PRE_NAME VAR_NAME SEMICOLON
##
## Ends in an error in state: 156.
##
## argument_expression_list -> argument_expression_list . COMMA assignment_expression [ RPAREN COMMA ]
## option(argument_expression_list) -> argument_expression_list . [ RPAREN ]
##
## The known suffix of the stack is as follows:
## argument_expression_list
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 87, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
## In state 145, spurious reduction of production assignment_expression -> conditional_expression 
## In state 155, spurious reduction of production argument_expression_list -> assignment_expression 
##

Up to this point, a list of expressions has been recognized:
  $0
If this list is complete,
then at this point, a closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME VAR_NAME LPAREN XOR_ASSIGN
##
## Ends in an error in state: 86.
##
## postfix_expression -> postfix_expression LPAREN . option(argument_expression_list) RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## postfix_expression LPAREN
##

# gcc and clang expect an expression: this is incomplete.

Ill-formed expression.
At this point, a list of expressions,
followed with a closing parenthesis ')', is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME VAR_NAME QUESTION PRE_NAME VAR_NAME COLON XOR_ASSIGN
##
## Ends in an error in state: 147.
##
## conditional_expression -> logical_or_expression QUESTION expression COLON . conditional_expression [ SEMICOLON RPAREN RBRACK RBRACE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## logical_or_expression QUESTION expression COLON
##
translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME VAR_NAME QUESTION XOR_ASSIGN
##
## Ends in an error in state: 125.
##
## conditional_expression -> logical_or_expression QUESTION . expression COLON conditional_expression [ SEMICOLON RPAREN RBRACK RBRACE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## logical_or_expression QUESTION
##

Ill-formed conditional expression.
At this point, an expression is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME VAR_NAME QUESTION PRE_NAME VAR_NAME SEMICOLON
##
## Ends in an error in state: 143.
##
## conditional_expression -> logical_or_expression QUESTION expression . COLON conditional_expression [ SEMICOLON RPAREN RBRACK RBRACE COMMA COLON ]
## expression -> expression . COMMA assignment_expression [ COMMA COLON ]
##
## The known suffix of the stack is as follows:
## logical_or_expression QUESTION expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 87, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
## In state 145, spurious reduction of production assignment_expression -> conditional_expression 
## In state 149, spurious reduction of production expression -> assignment_expression 
##

# gcc and clang simply expect a colon.

Ill-formed conditional expression.
Up to this point, an expression, '?', and an expression have been recognized:
  $2
  $1
  $0
If the last expression is complete,
then at this point, a colon ':' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: PACKED LPAREN PRE_NAME VAR_NAME SEMICOLON
##
## Ends in an error in state: 399.
##
## argument_expression_list -> argument_expression_list . COMMA assignment_expression [ RPAREN COMMA ]
## attribute_specifier -> PACKED LPAREN argument_expression_list . RPAREN [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE STRUCT STRING_LITERAL STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER RBRACK PRE_NAME PLUS PACKED NORETURN MINUS LPAREN LONG LBRACK LBRACE INT INLINE INC FLOAT EXTERN EQ ENUM DOUBLE DEC CONSTANT CONST COMMA COLON CHAR BUILTIN_VA_ARG BUILTIN_OFFSETOF BANG AUTO ATTRIBUTE AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## PACKED LPAREN argument_expression_list
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 87, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
## In state 145, spurious reduction of production assignment_expression -> conditional_expression 
## In state 155, spurious reduction of production argument_expression_list -> assignment_expression 
##

Ill-formed $2 attribute.
Up to this point, a list of expressions has been recognized:
  $0
If this list is complete,
then at this point, a closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: PACKED LPAREN XOR_ASSIGN
##
## Ends in an error in state: 19.
##
## attribute_specifier -> PACKED LPAREN . argument_expression_list RPAREN [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE STRUCT STRING_LITERAL STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER RBRACK PRE_NAME PLUS PACKED NORETURN MINUS LPAREN LONG LBRACK LBRACE INT INLINE INC FLOAT EXTERN EQ ENUM DOUBLE DEC CONSTANT CONST COMMA COLON CHAR BUILTIN_VA_ARG BUILTIN_OFFSETOF BANG AUTO ATTRIBUTE AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## PACKED LPAREN
##

# clang expects a "parameter declarator" (?).
# gcc expects "declaration specifiers or â...â".
#   Which is incorrect, since an ellipsis is rejected here.

Ill-formed $1 attribute.
At this point, a list of expressions is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ PRE_NAME TYPEDEF_NAME
##
## Ends in an error in state: 24.
##
## primary_expression -> PRE_NAME . VAR_NAME [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## PRE_NAME
##

Ill-formed expression.
The following identifier is used as a variable, but has been defined as a type:
  $0

# ------------------------------------------------------------------------------

translation_unit_file: PACKED XOR_ASSIGN
##
## Ends in an error in state: 18.
##
## attribute_specifier -> PACKED . LPAREN argument_expression_list RPAREN [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE STRUCT STRING_LITERAL STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER RBRACK PRE_NAME PLUS PACKED NORETURN MINUS LPAREN LONG LBRACK LBRACE INT INLINE INC FLOAT EXTERN EQ ENUM DOUBLE DEC CONSTANT CONST COMMA COLON CHAR BUILTIN_VA_ARG BUILTIN_OFFSETOF BANG AUTO ATTRIBUTE AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## PACKED
##

# This one seems important, since CompCert currently does not support __packed__
# without an argument.

Ill-formed $0 attribute.
At this point, an opening parenthesis '(',
followed with a possibly empty list of expressions,
is expected.

# ------------------------------------------------------------------------------

translation_unit_file: XOR_ASSIGN
##
## Ends in an error in state: 2.
##
## list(translation_item) -> list(translation_item) . translation_item [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF STRUCT STATIC_ASSERT STATIC SIGNED SHORT SEMICOLON RESTRICT REGISTER PRE_NAME PRAGMA PACKED NORETURN LONG INT INLINE FLOAT EXTERN EOF ENUM DOUBLE CONST CHAR AUTO ATTRIBUTE ALIGNAS ]
## translation_unit_file -> list(translation_item) . EOF [ # ]
##
## The known suffix of the stack is as follows:
## list(translation_item)
##

# We are at the toplevel.

# clang and gcc want an identifier or an opening parenthesis, which is way incomplete.

At this point, one of the following is expected:
  a function definition; or
  a declaration; or
  a pragma; or
  the end of the file.

# ------------------------------------------------------------------------------

translation_unit_file: TYPEDEF PRE_NAME TYPEDEF_NAME XOR_ASSIGN
##
## Ends in an error in state: 402.
##
## declaration_specifiers_typedef -> TYPEDEF list(declaration_specifier_no_type) typedef_name list(declaration_specifier_no_type) . [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . storage_class_specifier_no_typedef [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . type_qualifier_noattr [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . function_specifier [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . attribute_specifier [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## TYPEDEF list(declaration_specifier_no_type) typedef_name list(declaration_specifier_no_type)
##
translation_unit_file: PRE_NAME TYPEDEF_NAME TYPEDEF XOR_ASSIGN
##
## Ends in an error in state: 411.
##
## declaration_specifiers_typedef -> typedef_name list(declaration_specifier_no_type) TYPEDEF list(declaration_specifier_no_type) . [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . storage_class_specifier_no_typedef [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . type_qualifier_noattr [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . function_specifier [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . attribute_specifier [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## typedef_name list(declaration_specifier_no_type) TYPEDEF list(declaration_specifier_no_type)
##
translation_unit_file: VOLATILE TYPEDEF PRE_NAME TYPEDEF_NAME XOR_ASSIGN
##
## Ends in an error in state: 422.
##
## declaration_specifiers_typedef -> rlist(declaration_specifier_no_type) TYPEDEF list(declaration_specifier_no_type) typedef_name list(declaration_specifier_no_type) . [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . storage_class_specifier_no_typedef [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . type_qualifier_noattr [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . function_specifier [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . attribute_specifier [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## rlist(declaration_specifier_no_type) TYPEDEF list(declaration_specifier_no_type) typedef_name list(declaration_specifier_no_type)
##
translation_unit_file: VOLATILE PRE_NAME TYPEDEF_NAME TYPEDEF XOR_ASSIGN
##
## Ends in an error in state: 428.
##
## declaration_specifiers_typedef -> rlist(declaration_specifier_no_type) typedef_name list(declaration_specifier_no_type) TYPEDEF list(declaration_specifier_no_type) . [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . storage_class_specifier_no_typedef [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . type_qualifier_noattr [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . function_specifier [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . attribute_specifier [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## rlist(declaration_specifier_no_type) typedef_name list(declaration_specifier_no_type) TYPEDEF list(declaration_specifier_no_type)
##
translation_unit_file: TYPEDEF INT XOR_ASSIGN
##
## Ends in an error in state: 404.
##
## declaration_specifiers_typedef -> TYPEDEF list(declaration_specifier_no_type) type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) . [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_typedef_name) -> list(declaration_specifier_no_typedef_name) . declaration_specifier_no_typedef_name [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC STAR SIGNED SHORT SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG INT INLINE FLOAT EXTERN ENUM DOUBLE CONST CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## TYPEDEF list(declaration_specifier_no_type) type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name)
##
translation_unit_file: INT TYPEDEF XOR_ASSIGN
##
## Ends in an error in state: 415.
##
## declaration_specifiers_typedef -> type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) TYPEDEF list(declaration_specifier_no_typedef_name) . [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_typedef_name) -> list(declaration_specifier_no_typedef_name) . declaration_specifier_no_typedef_name [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC STAR SIGNED SHORT SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG INT INLINE FLOAT EXTERN ENUM DOUBLE CONST CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) TYPEDEF list(declaration_specifier_no_typedef_name)
##
translation_unit_file: VOLATILE TYPEDEF INT XOR_ASSIGN
##
## Ends in an error in state: 424.
##
## declaration_specifiers_typedef -> rlist(declaration_specifier_no_type) TYPEDEF list(declaration_specifier_no_type) type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) . [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_typedef_name) -> list(declaration_specifier_no_typedef_name) . declaration_specifier_no_typedef_name [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC STAR SIGNED SHORT SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG INT INLINE FLOAT EXTERN ENUM DOUBLE CONST CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## rlist(declaration_specifier_no_type) TYPEDEF list(declaration_specifier_no_type) type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name)
##
translation_unit_file: VOLATILE INT TYPEDEF XOR_ASSIGN
##
## Ends in an error in state: 432.
##
## declaration_specifiers_typedef -> rlist(declaration_specifier_no_type) type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) TYPEDEF list(declaration_specifier_no_typedef_name) . [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_typedef_name) -> list(declaration_specifier_no_typedef_name) . declaration_specifier_no_typedef_name [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC STAR SIGNED SHORT SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG INT INLINE FLOAT EXTERN ENUM DOUBLE CONST CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## rlist(declaration_specifier_no_type) type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) TYPEDEF list(declaration_specifier_no_typedef_name)
##

# We have begun a type definition (a.k.a. declaration_specifiers_typedef).
# To complete this type definition,
# we expect a possibly-empty list declaration_specifiers_no_type?,
#                               or declaration_specifiers_no_typedef_name?,
# (depending on which example sentence one looks at)
# which (in all cases) means a list of:
#   storage class specifiers,
#   type qualifiers,
#   function specifiers (i.e., INLINE, but I suspect this is illegal here).
# and (in the second case) also includes:
#   type_specifier_no_typedef_name (e.g., INT, etc.).
# After this type definition,
# we expect typedef_declarator_list? SEMICOLON.

# We omit the possibility of giving another type specifier, such as INT.

# We could omit the possibility of a storage class specifier and a type qualifier.

# gcc and clang expect identifier or '(', which is correct but incomplete (and too low-level).

Ill-formed type definition.
At this point, one of the following is expected:
  a storage class specifier; or
  a type qualifier; or
  a list of declarators, followed with a semicolon ';'.

# ------------------------------------------------------------------------------

translation_unit_file: TYPEDEF XOR_ASSIGN
##
## Ends in an error in state: 9.
##
## declaration_specifiers_typedef -> TYPEDEF list(declaration_specifier_no_type) . typedef_name list(declaration_specifier_no_type) [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers_typedef -> TYPEDEF list(declaration_specifier_no_type) . type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . storage_class_specifier_no_typedef [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC SIGNED SHORT RESTRICT REGISTER PRE_NAME PACKED NORETURN LONG INT INLINE FLOAT EXTERN ENUM DOUBLE CONST CHAR AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . type_qualifier_noattr [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC SIGNED SHORT RESTRICT REGISTER PRE_NAME PACKED NORETURN LONG INT INLINE FLOAT EXTERN ENUM DOUBLE CONST CHAR AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . function_specifier [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC SIGNED SHORT RESTRICT REGISTER PRE_NAME PACKED NORETURN LONG INT INLINE FLOAT EXTERN ENUM DOUBLE CONST CHAR AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . attribute_specifier [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC SIGNED SHORT RESTRICT REGISTER PRE_NAME PACKED NORETURN LONG INT INLINE FLOAT EXTERN ENUM DOUBLE CONST CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## TYPEDEF list(declaration_specifier_no_type)
##
translation_unit_file: VOLATILE TYPEDEF XOR_ASSIGN
##
## Ends in an error in state: 420.
##
## declaration_specifiers_typedef -> rlist(declaration_specifier_no_type) TYPEDEF list(declaration_specifier_no_type) . typedef_name list(declaration_specifier_no_type) [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers_typedef -> rlist(declaration_specifier_no_type) TYPEDEF list(declaration_specifier_no_type) . type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . storage_class_specifier_no_typedef [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC SIGNED SHORT RESTRICT REGISTER PRE_NAME PACKED NORETURN LONG INT INLINE FLOAT EXTERN ENUM DOUBLE CONST CHAR AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . type_qualifier_noattr [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC SIGNED SHORT RESTRICT REGISTER PRE_NAME PACKED NORETURN LONG INT INLINE FLOAT EXTERN ENUM DOUBLE CONST CHAR AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . function_specifier [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC SIGNED SHORT RESTRICT REGISTER PRE_NAME PACKED NORETURN LONG INT INLINE FLOAT EXTERN ENUM DOUBLE CONST CHAR AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . attribute_specifier [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC SIGNED SHORT RESTRICT REGISTER PRE_NAME PACKED NORETURN LONG INT INLINE FLOAT EXTERN ENUM DOUBLE CONST CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## rlist(declaration_specifier_no_type) TYPEDEF list(declaration_specifier_no_type)
##

# We have seen the TYPEDEF keyword, and possibly some declaration_specifiers_no_type.
# We expect:
# possibly more declaration_specifiers_no_type?,
#   which means a list of:
#     storage class specifiers,
#     type qualifiers,
#     function specifiers (i.e., INLINE, but I suspect this is illegal here).
# followed with a type specifier.

# gcc and clang expect identifier or '('.

Ill-formed type definition.
At this point, one of the following is expected:
  a storage class specifier; or
  a type qualifier; or
  a type specifier.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN VOLATILE XOR_ASSIGN
##
## Ends in an error in state: 230.
##
## declaration_specifiers(parameter_declaration) -> rlist(declaration_specifier_no_type) . typedef_name list(declaration_specifier_no_type) [ STAR RPAREN PRE_NAME LPAREN LBRACK COMMA ]
## declaration_specifiers(parameter_declaration) -> rlist(declaration_specifier_no_type) . type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) [ STAR RPAREN PRE_NAME LPAREN LBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## rlist(declaration_specifier_no_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 222, spurious reduction of production rlist(declaration_specifier_no_type) -> type_qualifier_noattr 
##

# Analogous to the above, except we are in the context of a parameter declaration,
# and (obviously) have not seen a TYPEDEF keyword.
# We expect possibly more declaration_specifiers_no_type?
# followed with a type specifier.
# I think it is OK to forbid INLINE here.

# (At this point, our declaration_specifiers will be complete, and the
# continuation would be declarator, abstract_declarator, or nothing,
# which implies COMMA or RPAREN. Let's not mention that, and describe
# things only up to the (required) type specifier.)

Ill-formed parameter declaration.
At this point, one of the following is expected:
  a storage class specifier; or
  a type qualifier; or
  a type specifier.

# ------------------------------------------------------------------------------

translation_unit_file: PRE_NAME TYPEDEF_NAME XOR_ASSIGN
##
## Ends in an error in state: 409.
##
## declaration_specifiers(declaration(external_declaration)) -> typedef_name list(declaration_specifier_no_type) . [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers_typedef -> typedef_name list(declaration_specifier_no_type) . TYPEDEF list(declaration_specifier_no_type) [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . storage_class_specifier_no_typedef [ VOLATILE TYPEDEF STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . type_qualifier_noattr [ VOLATILE TYPEDEF STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . function_specifier [ VOLATILE TYPEDEF STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . attribute_specifier [ VOLATILE TYPEDEF STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## typedef_name list(declaration_specifier_no_type)
##
translation_unit_file: VOLATILE PRE_NAME TYPEDEF_NAME XOR_ASSIGN
##
## Ends in an error in state: 426.
##
## declaration_specifiers(declaration(external_declaration)) -> rlist(declaration_specifier_no_type) typedef_name list(declaration_specifier_no_type) . [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers_typedef -> rlist(declaration_specifier_no_type) typedef_name list(declaration_specifier_no_type) . TYPEDEF list(declaration_specifier_no_type) [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . storage_class_specifier_no_typedef [ VOLATILE TYPEDEF STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . type_qualifier_noattr [ VOLATILE TYPEDEF STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . function_specifier [ VOLATILE TYPEDEF STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . attribute_specifier [ VOLATILE TYPEDEF STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## rlist(declaration_specifier_no_type) typedef_name list(declaration_specifier_no_type)
##
translation_unit_file: INT XOR_ASSIGN
##
## Ends in an error in state: 413.
##
## declaration_specifiers(declaration(external_declaration)) -> type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) . [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers_typedef -> type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) . TYPEDEF list(declaration_specifier_no_typedef_name) [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_typedef_name) -> list(declaration_specifier_no_typedef_name) . declaration_specifier_no_typedef_name [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF STRUCT STATIC STAR SIGNED SHORT SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG INT INLINE FLOAT EXTERN ENUM DOUBLE CONST CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name)
##
translation_unit_file: VOLATILE INT XOR_ASSIGN
##
## Ends in an error in state: 430.
##
## declaration_specifiers(declaration(external_declaration)) -> rlist(declaration_specifier_no_type) type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) . [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers_typedef -> rlist(declaration_specifier_no_type) type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) . TYPEDEF list(declaration_specifier_no_typedef_name) [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_typedef_name) -> list(declaration_specifier_no_typedef_name) . declaration_specifier_no_typedef_name [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF STRUCT STATIC STAR SIGNED SHORT SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG INT INLINE FLOAT EXTERN ENUM DOUBLE CONST CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## rlist(declaration_specifier_no_type) type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name)
##

# We have seen a TYPEDEF_NAME or a primitive type specifier,
# and possibly some declaration_specifiers_no_type.
# We expect:
# possibly more declaration_specifier_no_type or declaration_specifier_no_typedef_name,
#   which means a list of:
#     storage class specifiers,
#     type qualifiers,
#     function specifiers,
#     possibly type specifiers,
# possibly followed with a TYPEDEF keyword.

# Note that we can get here via spurious reductions (e.g. "enum foo" can
# be considered a complete enum_specifier, hence a complete type_specifier).
# Thus, the list of permitted continuations below can be slightly incomplete:
# an opening brace could be used to continue "enum foo".

# Let's NOT mention the possibility of placing TYPEDEF somewhere in the middle.
# This means we pretend to be definitely in a declaration_specifiers(declaration).
# In other words, we are in the beginning of a declaration of function definition
# (we do not know which, yet).

# Let's also ignore the possibility of writing INLINE *after* the result type,
# which sounds awkward.

# If this declaration_specifiers is complete,
# then we expect:
#   init_declarator_list? SEMICOLON          if this is a declaration;
#   declarator                               if this is a function definition.
#                                            (followed with a function body)

# gcc and clang expect identifier or '(', which is very low-level.

# We simplify "a list of init declarators" to "an init declarator".

# Our message is probably too elaborate; we could omit certain elements,
# or try to simplify our description in the case of a function definition.

Ill-formed declaration or function definition.
At this point, one of the following is expected:
  a storage class specifier; or
  a type qualifier; or
  an init declarator,
    if this is a declaration; or
  a declarator,
    followed with a function body,
    if this is a function definition.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN PRE_NAME TYPEDEF_NAME XOR_ASSIGN
##
## Ends in an error in state: 209.
##
## declaration_specifiers(parameter_declaration) -> typedef_name list(declaration_specifier_no_type) . [ STAR RPAREN PRE_NAME LPAREN LBRACK COMMA ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . storage_class_specifier_no_typedef [ VOLATILE STATIC STAR RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LBRACK INLINE EXTERN CONST COMMA AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . type_qualifier_noattr [ VOLATILE STATIC STAR RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LBRACK INLINE EXTERN CONST COMMA AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . function_specifier [ VOLATILE STATIC STAR RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LBRACK INLINE EXTERN CONST COMMA AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . attribute_specifier [ VOLATILE STATIC STAR RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LBRACK INLINE EXTERN CONST COMMA AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## typedef_name list(declaration_specifier_no_type)
##
translation_unit_file: INT PRE_NAME VAR_NAME LPAREN VOLATILE PRE_NAME TYPEDEF_NAME XOR_ASSIGN
##
## Ends in an error in state: 232.
##
## declaration_specifiers(parameter_declaration) -> rlist(declaration_specifier_no_type) typedef_name list(declaration_specifier_no_type) . [ STAR RPAREN PRE_NAME LPAREN LBRACK COMMA ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . storage_class_specifier_no_typedef [ VOLATILE STATIC STAR RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LBRACK INLINE EXTERN CONST COMMA AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . type_qualifier_noattr [ VOLATILE STATIC STAR RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LBRACK INLINE EXTERN CONST COMMA AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . function_specifier [ VOLATILE STATIC STAR RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LBRACK INLINE EXTERN CONST COMMA AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . attribute_specifier [ VOLATILE STATIC STAR RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LBRACK INLINE EXTERN CONST COMMA AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## rlist(declaration_specifier_no_type) typedef_name list(declaration_specifier_no_type)
##
translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT XOR_ASSIGN
##
## Ends in an error in state: 215.
##
## declaration_specifiers(parameter_declaration) -> type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) . [ STAR RPAREN PRE_NAME LPAREN LBRACK COMMA ]
## list(declaration_specifier_no_typedef_name) -> list(declaration_specifier_no_typedef_name) . declaration_specifier_no_typedef_name [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC STAR SIGNED SHORT RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG LBRACK INT INLINE FLOAT EXTERN ENUM DOUBLE CONST COMMA CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name)
##
translation_unit_file: INT PRE_NAME VAR_NAME LPAREN VOLATILE INT XOR_ASSIGN
##
## Ends in an error in state: 234.
##
## declaration_specifiers(parameter_declaration) -> rlist(declaration_specifier_no_type) type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) . [ STAR RPAREN PRE_NAME LPAREN LBRACK COMMA ]
## list(declaration_specifier_no_typedef_name) -> list(declaration_specifier_no_typedef_name) . declaration_specifier_no_typedef_name [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC STAR SIGNED SHORT RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG LBRACK INT INLINE FLOAT EXTERN ENUM DOUBLE CONST COMMA CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## rlist(declaration_specifier_no_type) type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name)
##

# Analogous to the above situation, except this time, we are in the
# context of a parameter declaration (as opposed to a declaration or
# function definition). This rules out 'typedef' and 'inline', for real,
# I think. Also, this changes the continuation.

# We have seen a type specifier,
# and possibly some declaration_specifiers_no_type.
# We expect:
# possibly more declaration_specifier_no_type or declaration_specifier_no_typedef_name,
#   which means a list of:
#     storage class specifiers,
#     type qualifiers.
#     (omitting the possibility of another type specifier)

# If this declaration_specifiers(parameter_declaration) is complete,
# then we expect:
#   declarator
#   abstract_declarator
#   or neither, which means that the parameter_declaration is over,
#   which means we expect COMMA or RPAREN.

# We could say that $1 has been interpreted as a type specifier,
# although I don't know if that would help.

# clang expects ')'.
# gcc expects â;â, â,â or â)â. The semicolon seems incorrect.

Ill-formed parameter declaration.
At this point, one of the following is expected:
  a storage class specifier; or
  a type qualifier; or
  a declarator; or
  an abstract declarator; or
  a comma ',', followed with a parameter declaration; or
  a closing parenthesis ')'.

# ------------------------------------------------------------------------------

translation_unit_file: VOLATILE XOR_ASSIGN
##
## Ends in an error in state: 418.
##
## declaration_specifiers(declaration(external_declaration)) -> rlist(declaration_specifier_no_type) . typedef_name list(declaration_specifier_no_type) [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers(declaration(external_declaration)) -> rlist(declaration_specifier_no_type) . type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers_typedef -> rlist(declaration_specifier_no_type) . TYPEDEF list(declaration_specifier_no_type) typedef_name list(declaration_specifier_no_type) [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers_typedef -> rlist(declaration_specifier_no_type) . typedef_name list(declaration_specifier_no_type) TYPEDEF list(declaration_specifier_no_type) [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers_typedef -> rlist(declaration_specifier_no_type) . TYPEDEF list(declaration_specifier_no_type) type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers_typedef -> rlist(declaration_specifier_no_type) . type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) TYPEDEF list(declaration_specifier_no_typedef_name) [ STAR SEMICOLON PRE_NAME LPAREN ]
##
## The known suffix of the stack is as follows:
## rlist(declaration_specifier_no_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 222, spurious reduction of production rlist(declaration_specifier_no_type) -> type_qualifier_noattr 
##

# We have seen some specifiers or qualifiers. We have probably seen at least
# one of them, otherwise we would be at the top level of the file, and the
# error would be signaled in another state, I think.

# This could be the beginning of a declaration or function definition.

# It could in theory be the beginning of a type definition, but only
# if the TYPEDEF keyword is not in front, which sounds awkward, so
# let's ignore that.

# Again, we ignore the possibility of INLINE when not in front, as it
# is awkward.

# We have not yet seen a type specifier, so we must see it, regardless
# of whether this is a declaration or function definition.

Ill-formed declaration or function definition.
At this point, one of the following is expected:
  a storage class specifier; or
  a type qualifier; or
  a type specifier.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE VOLATILE XOR_ASSIGN
##
## Ends in an error in state: 528.
##
## declaration_specifiers(declaration(block_item)) -> rlist(declaration_specifier_no_type) . typedef_name list(declaration_specifier_no_type) [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers(declaration(block_item)) -> rlist(declaration_specifier_no_type) . type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers_typedef -> rlist(declaration_specifier_no_type) . TYPEDEF list(declaration_specifier_no_type) typedef_name list(declaration_specifier_no_type) [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers_typedef -> rlist(declaration_specifier_no_type) . typedef_name list(declaration_specifier_no_type) TYPEDEF list(declaration_specifier_no_type) [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers_typedef -> rlist(declaration_specifier_no_type) . TYPEDEF list(declaration_specifier_no_type) type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers_typedef -> rlist(declaration_specifier_no_type) . type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) TYPEDEF list(declaration_specifier_no_typedef_name) [ STAR SEMICOLON PRE_NAME LPAREN ]
##
## The known suffix of the stack is as follows:
## rlist(declaration_specifier_no_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 222, spurious reduction of production rlist(declaration_specifier_no_type) -> type_qualifier_noattr 
##
# Identical to the previous one, except we are not at the top level,
# so we know this cannot be the beginning of a function definition.

Ill-formed declaration.
At this point, one of the following is expected:
  a storage class specifier; or
  a type qualifier; or
  a type specifier.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE PRE_NAME TYPEDEF_NAME VOLATILE XOR_ASSIGN
##
## Ends in an error in state: 524.
##
## declaration_specifiers(declaration(block_item)) -> typedef_name list(declaration_specifier_no_type) . [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers_typedef -> typedef_name list(declaration_specifier_no_type) . TYPEDEF list(declaration_specifier_no_type) [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . storage_class_specifier_no_typedef [ VOLATILE TYPEDEF STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . type_qualifier_noattr [ VOLATILE TYPEDEF STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . function_specifier [ VOLATILE TYPEDEF STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . attribute_specifier [ VOLATILE TYPEDEF STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## typedef_name list(declaration_specifier_no_type)
##
translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE VOLATILE PRE_NAME TYPEDEF_NAME XOR_ASSIGN
##
## Ends in an error in state: 530.
##
## declaration_specifiers(declaration(block_item)) -> rlist(declaration_specifier_no_type) typedef_name list(declaration_specifier_no_type) . [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers_typedef -> rlist(declaration_specifier_no_type) typedef_name list(declaration_specifier_no_type) . TYPEDEF list(declaration_specifier_no_type) [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . storage_class_specifier_no_typedef [ VOLATILE TYPEDEF STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . type_qualifier_noattr [ VOLATILE TYPEDEF STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . function_specifier [ VOLATILE TYPEDEF STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . attribute_specifier [ VOLATILE TYPEDEF STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## rlist(declaration_specifier_no_type) typedef_name list(declaration_specifier_no_type)
##
translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE INT XOR_ASSIGN
##
## Ends in an error in state: 526.
##
## declaration_specifiers(declaration(block_item)) -> type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) . [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers_typedef -> type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) . TYPEDEF list(declaration_specifier_no_typedef_name) [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_typedef_name) -> list(declaration_specifier_no_typedef_name) . declaration_specifier_no_typedef_name [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF STRUCT STATIC STAR SIGNED SHORT SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG INT INLINE FLOAT EXTERN ENUM DOUBLE CONST CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name)
##
translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE VOLATILE INT XOR_ASSIGN
##
## Ends in an error in state: 532.
##
## declaration_specifiers(declaration(block_item)) -> rlist(declaration_specifier_no_type) type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) . [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers_typedef -> rlist(declaration_specifier_no_type) type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) . TYPEDEF list(declaration_specifier_no_typedef_name) [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_typedef_name) -> list(declaration_specifier_no_typedef_name) . declaration_specifier_no_typedef_name [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF STRUCT STATIC STAR SIGNED SHORT SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG INT INLINE FLOAT EXTERN ENUM DOUBLE CONST CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## rlist(declaration_specifier_no_type) type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name)
##

# This is analogous to the error sentence TYPEDEF_NAME VOLATILE XOR_ASSIGN,
# except we are inside a block, instead of at the top level, so we
# know that this cannot be the beginning of a function definition.

# This is an interesting situation where, by using phantom parameters,
# we have forced a distinction between two states that would NOT be
# distinguished in a canonical automaton. Indeed, the lookahead sets
# are the same: the states would be the same if the phantom parameters
# were erased.

# Assuming that the list of init declarators is nonempty, we say that
# we expect an init declarator, instead of saying that we expect a
# possibly empty, comma-separated list of init declarators, followed
# with a semicolon.

# We do not distinguish the case where we have seen a primitive type
# specifier, so another primitive type specifier would be OK.

# gcc and clang expect identifier or '(', which is incomplete and low-level.

Ill-formed declaration.
At this point, one of the following is expected:
  a storage class specifier; or
  a type qualifier; or
  an init declarator.

# ------------------------------------------------------------------------------

translation_unit_file: UNION LBRACE PRE_NAME TYPEDEF_NAME XOR_ASSIGN
##
## Ends in an error in state: 189.
##
## struct_declaration -> specifier_qualifier_list(struct_declaration) . option(struct_declarator_list) SEMICOLON [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC_ASSERT SIGNED SHORT RESTRICT RBRACE PRE_NAME PACKED LONG INT FLOAT ENUM DOUBLE CONST CHAR ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## specifier_qualifier_list(struct_declaration)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production specifier_qualifier_list(struct_declaration) -> typedef_name option(type_qualifier_list) 
##

# We have (spuriously) recognized a specifier_qualifier_list,
# part of a struct_declaration.
# Thus, we expect:
#   more type qualifiers or specifiers (part of the specifier_qualifier_list), or
#   a struct declarator, or
#   a semicolon.

# The nonterminal symbol is officially called struct-declaration.
# But this means struct *or union*,
# and it is a declaration of a struct or union *member*.

# It seems good to show the type specifier that we have just read (if
# there is one), as it could be a variable name that has been
# mis-classified as a type name, I suppose.

# clang's message is analogous to ours.
# gcc expects identifier or '('.

Ill-formed struct declaration.
Up to this point,
a list of type qualifiers and type specifiers has been recognized:
  $0
If this list is complete, then 
at this point, one of the following is expected:
  a struct declarator; or
  a semicolon ';'.

# ------------------------------------------------------------------------------

translation_unit_file: UNION LBRACE LONG COLON CONSTANT RPAREN
##
## Ends in an error in state: 295.
##
## option(struct_declarator_list) -> struct_declarator_list . [ SEMICOLON ]
## struct_declarator_list -> struct_declarator_list . COMMA struct_declarator [ SEMICOLON COMMA ]
##
## The known suffix of the stack is as follows:
## struct_declarator_list
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 79, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
## In state 300, spurious reduction of production struct_declarator -> option(declarator) COLON conditional_expression 
## In state 302, spurious reduction of production struct_declarator_list -> struct_declarator 
##

# We have seen a non-empty struct_declarator_list.

# clang expects a semicolon, like us.
# gcc expects too many things (incorrect).

Ill-formed struct declaration.
Up to this point, a list of struct declarators has been recognized:
  $0
If this list is complete,
then at this point, a semicolon ';' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: UNION LBRACE INT COLON XOR_ASSIGN
##
## Ends in an error in state: 299.
##
## struct_declarator -> option(declarator) COLON . conditional_expression [ SEMICOLON COMMA ]
##
## The known suffix of the stack is as follows:
## option(declarator) COLON
##

Ill-formed struct declarator.
At this point, a constant expression is expected.

# ------------------------------------------------------------------------------

translation_unit_file: UNION LBRACE INT PRE_NAME VAR_NAME COMMA XOR_ASSIGN
##
## Ends in an error in state: 296.
##
## struct_declarator_list -> struct_declarator_list COMMA . struct_declarator [ SEMICOLON COMMA ]
##
## The known suffix of the stack is as follows:
## struct_declarator_list COMMA
##

Ill-formed struct declaration.
At this point, a struct declarator is expected.

# ------------------------------------------------------------------------------

translation_unit_file: UNION LBRACE INT PRE_NAME VAR_NAME RPAREN
##
## Ends in an error in state: 301.
##
## option(declarator) -> declarator . [ COLON ]
## struct_declarator -> declarator . [ SEMICOLON COMMA ]
##
## The known suffix of the stack is as follows:
## declarator
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 263, spurious reduction of production declarator_noattrend -> direct_declarator 
## In state 268, spurious reduction of production attribute_specifier_list -> 
## In state 269, spurious reduction of production declarator -> declarator_noattrend attribute_specifier_list 
##

# Assuming the declarator so far is complete, we expect
# either COLON constant_expression (part of this struct_declarator)
# or something that follows this struct_declarator.

# clang expects ';'.
# gcc expects many things, including '}', which seems incorrect.

Ill-formed struct declaration.
Up to this point, a declarator has been recognized:
  $0
If this declarator is complete,
then at this point, one of the following is expected:
  a colon ':', followed with a constant expression; or
  a comma ',', followed with a struct declarator; or
  a semicolon ';'.

# ------------------------------------------------------------------------------

translation_unit_file: UNION LBRACE VOLATILE ADD_ASSIGN
##
## Ends in an error in state: 182.
##
## option(type_qualifier_list) -> type_qualifier_list . [ VOLATILE RESTRICT PACKED CONST ATTRIBUTE ALIGNAS ]
## specifier_qualifier_list(struct_declaration) -> type_qualifier_list . typedef_name option(type_qualifier_list) [ STAR SEMICOLON PRE_NAME LPAREN COLON ]
## specifier_qualifier_list(struct_declaration) -> type_qualifier_list . type_specifier_no_typedef_name list(specifier_qualifier_no_typedef_name) [ STAR SEMICOLON PRE_NAME LPAREN COLON ]
##
## The known suffix of the stack is as follows:
## type_qualifier_list
##

# A list of qualifiers has been read.
#   (Probably a nonempty list, otherwise we would be in a different state.)
# We expect a type specifier, or one more qualifier.

Ill-formed struct declaration.
At this point, one of the following is expected:
  a type qualifier; or
  a type specifier.

# ------------------------------------------------------------------------------

translation_unit_file: UNION LBRACE XOR_ASSIGN
##
## Ends in an error in state: 75.
##
## struct_declaration_list -> struct_declaration_list . struct_declaration [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC_ASSERT SIGNED SHORT RESTRICT RBRACE PRE_NAME PACKED LONG INT FLOAT ENUM DOUBLE CONST CHAR ATTRIBUTE ALIGNAS ]
## struct_or_union_specifier -> struct_or_union attribute_specifier_list option(other_identifier) LBRACE struct_declaration_list . RBRACE [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF STRUCT STATIC STAR SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG LBRACK INT INLINE FLOAT EXTERN ENUM DOUBLE CONST COMMA COLON CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## struct_or_union attribute_specifier_list option(other_identifier) LBRACE struct_declaration_list
##

# gcc and clang do not seem prepared to accept a struct or union with
# zero members, so they request a type specifier or qualifier.

At this point, one of the following is expected:
  a struct declaration; or
  a closing brace '}'.

# ------------------------------------------------------------------------------

translation_unit_file: UNION XOR_ASSIGN
##
## Ends in an error in state: 72.
##
## struct_or_union_specifier -> struct_or_union attribute_specifier_list . option(other_identifier) LBRACE struct_declaration_list RBRACE [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF STRUCT STATIC STAR SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG LBRACK INT INLINE FLOAT EXTERN ENUM DOUBLE CONST COMMA COLON CHAR AUTO ATTRIBUTE ALIGNAS ]
## struct_or_union_specifier -> struct_or_union attribute_specifier_list . general_identifier [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF STRUCT STATIC STAR SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG LBRACK INT INLINE FLOAT EXTERN ENUM DOUBLE CONST COMMA COLON CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## struct_or_union attribute_specifier_list
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 71, spurious reduction of production attribute_specifier_list -> 
##

# gcc expects '{'.
# clang gives a mysterious message: "declaration of anonymous union must be a definition".
#   Adding TYPEDEF in front does not help.

Ill-formed struct or union specifier.
At this point, one of the following is expected:
  an attribute specifier; or
  an identifier; or
  an opening brace '{', followed with a list of members.

# ------------------------------------------------------------------------------

translation_unit_file: INT LPAREN PRE_NAME VAR_NAME SEMICOLON
##
## Ends in an error in state: 272.
##
## direct_declarator -> LPAREN save_context declarator . RPAREN [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG LBRACK LBRACE INT INLINE FLOAT EXTERN EQ ENUM DOUBLE CONST COMMA COLON CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## LPAREN save_context declarator
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 263, spurious reduction of production declarator_noattrend -> direct_declarator 
## In state 268, spurious reduction of production attribute_specifier_list -> 
## In state 269, spurious reduction of production declarator -> declarator_noattrend attribute_specifier_list 
##

Up to this point, a declarator has been recognized:
  $0
If this declarator is complete,
then at this point, a closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT LPAREN XOR_ASSIGN
##
## Ends in an error in state: 195.
##
## direct_declarator -> LPAREN save_context . declarator RPAREN [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG LBRACK LBRACE INT INLINE FLOAT EXTERN EQ ENUM DOUBLE CONST COMMA COLON CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## LPAREN save_context
##

# clang and gcc expect identifier or '(', as usual.

Ill-formed direct declarator.
At this point, a declarator is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN PRE_NAME VAR_NAME XOR_ASSIGN
##
## Ends in an error in state: 289.
##
## identifier_list -> identifier_list . COMMA PRE_NAME VAR_NAME [ RPAREN COMMA ]
## option(identifier_list) -> identifier_list . [ RPAREN ]
##
## The known suffix of the stack is as follows:
## identifier_list
##

Ill-formed K&R function definition.
Up to this point, a list of identifiers has been recognized:
  $0
If this list is complete,
then at this point, a closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN XOR_ASSIGN
##
## Ends in an error in state: 201.
##
## context_parameter_type_list -> save_context . parameter_type_list save_context [ RPAREN ]
## direct_declarator -> direct_declarator LPAREN save_context . option(identifier_list) RPAREN [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG LBRACK LBRACE INT INLINE FLOAT EXTERN EQ ENUM DOUBLE CONST COMMA COLON CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## direct_declarator LPAREN save_context
##

# Ignore K&R syntax, just request ANSI syntax.

# Ignore the distinction between parameter-type-list and parameter-list.

# clang expects a parameter declarator (which is incomplete).
# gcc expects declaration specifiers or â...â (which is incorrect).

Ill-formed function definition.
At this point, a list of parameter declarations,
followed with a closing parenthesis ')', is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT STAR RPAREN
##
## Ends in an error in state: 198.
##
## declarator_noattrend -> list(pointer1) STAR option(type_qualifier_list) . direct_declarator [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LONG LBRACE INT INLINE FLOAT EXTERN EQ ENUM DOUBLE CONST COMMA COLON CHAR AUTO ATTRIBUTE ALIGNAS ]
## list(pointer1) -> list(pointer1) STAR option(type_qualifier_list) . [ STAR ]
## type_qualifier_list -> option(type_qualifier_list) . type_qualifier_noattr [ VOLATILE STAR RESTRICT PRE_NAME PACKED LPAREN CONST ATTRIBUTE ALIGNAS ]
## type_qualifier_list -> option(type_qualifier_list) . attribute_specifier [ VOLATILE STAR RESTRICT PRE_NAME PACKED LPAREN CONST ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## list(pointer1) STAR option(type_qualifier_list)
##

# If the pointer isn't finished, we expect
#   one more type qualifier; or
#   one more '*', possibly followed with type qualifiers.
# If the pointer is finished, then we expect a direct declarator.

# If may seem tempting to declare %on_error_reduce "list(pointer1)", but
# that would clash with %on_error_reduce "abstract_declarator(type_name)".
# There are states where both reductions are enabled, and Menhir currently
# refuses to choose between them.

# clang and gcc expect identifier or '(', as usual.

Ill-formed declarator.
At this point, one of the following is expected:
  a type qualifier; or
  a star '*', possibly followed with type qualifiers; or
  a direct declarator.

# ------------------------------------------------------------------------------

translation_unit_file: TYPEDEF INT PRE_NAME VAR_NAME XOR_ASSIGN
##
## Ends in an error in state: 544.
##
## option(typedef_declarator_list) -> typedef_declarator_list . [ SEMICOLON ]
## typedef_declarator_list -> typedef_declarator_list . COMMA typedef_declarator [ SEMICOLON COMMA ]
##
## The known suffix of the stack is as follows:
## typedef_declarator_list
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 263, spurious reduction of production declarator_noattrend -> direct_declarator 
## In state 268, spurious reduction of production attribute_specifier_list -> 
## In state 269, spurious reduction of production declarator -> declarator_noattrend attribute_specifier_list 
## In state 548, spurious reduction of production declare_typename(declarator) -> declarator 
## In state 547, spurious reduction of production typedef_declarator -> declare_typename(declarator) 
## In state 549, spurious reduction of production typedef_declarator_list -> typedef_declarator 
##

# Because attribute_specifier_list, declarator and declarator_noattrend have been marked
# %on_error_reduce, we perform several spurious reductions and end up here.
# Which is good, because the context is clear.

# If the attribute_specifier_list or declarator was not finished, then we could have accepted:
#  an attribute specifier.
#  a opening bracket '['.
#  an opening parenthesis '('.

# As far as the C grammar is concerned, typedef_declarator is just declarator.

# clang says "invalid token after top level declarator", which seems vague.
# gcc expects a list of many things...

Up to this point, a list of declarators has been recognized:
  $0
If this list is complete,
then at this point, a semicolon ';' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: TYPEDEF INT PRE_NAME VAR_NAME COMMA XOR_ASSIGN
##
## Ends in an error in state: 545.
##
## typedef_declarator_list -> typedef_declarator_list COMMA . typedef_declarator [ SEMICOLON COMMA ]
##
## The known suffix of the stack is as follows:
## typedef_declarator_list COMMA
##

At this point, a declarator is expected.

# ------------------------------------------------------------------------------

translation_unit_file: ALIGNAS LPAREN INT LPAREN RPAREN LPAREN XOR_ASSIGN
##
## Ends in an error in state: 257.
##
## direct_abstract_declarator -> direct_abstract_declarator LPAREN . option(context_parameter_type_list) RPAREN [ RPAREN LPAREN LBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## direct_abstract_declarator LPAREN
##

At this point, a list of parameter declarations,
followed with a closing parenthesis ')', is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE ASM CONST XOR_ASSIGN
##
## Ends in an error in state: 459.
##
## asm_attributes -> CONST . asm_attributes [ LPAREN ]
##
## The known suffix of the stack is as follows:
## CONST
##
translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE ASM VOLATILE XOR_ASSIGN
##
## Ends in an error in state: 458.
##
## asm_attributes -> VOLATILE . asm_attributes [ LPAREN ]
##
## The known suffix of the stack is as follows:
## VOLATILE
##
translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE ASM XOR_ASSIGN
##
## Ends in an error in state: 457.
##
## asm_statement -> ASM . asm_attributes LPAREN string_literals_list asm_arguments RPAREN SEMICOLON [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## ASM
##

Ill-formed assembly statement.
At this point, one of the following is expected:
  an assembly attribute, such as 'volatile'; or
  an opening parenthesis '('.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE ASM LPAREN STRING_LITERAL COLON COLON COLON STRING_LITERAL COMMA XOR_ASSIGN
##
## Ends in an error in state: 483.
##
## asm_flags -> asm_flags COMMA . string_literals_list [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## asm_flags COMMA
##
# We are in the clobber list.
# We have seen a comma, so we expect a string literal.
# first(asm_flags) = STRING_LITERAL
translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE ASM LPAREN STRING_LITERAL COLON COLON COLON XOR_ASSIGN
##
## Ends in an error in state: 480.
##
## asm_arguments -> COLON asm_operands COLON asm_operands COLON . asm_flags [ RPAREN ]
##
## The known suffix of the stack is as follows:
## COLON asm_operands COLON asm_operands COLON
##
# We are at the beginning of the clobber list.
# first(asm_flags) = STRING_LITERAL

Ill-formed assembly statement.
At this point, a clobbered resource is expected.
Examples of clobbered resources:
  "memory"
  "eax"

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE ASM LPAREN STRING_LITERAL COLON COLON COLON STRING_LITERAL XOR_ASSIGN
##
## Ends in an error in state: 482.
##
## asm_arguments -> COLON asm_operands COLON asm_operands COLON asm_flags . [ RPAREN ]
## asm_flags -> asm_flags . COMMA string_literals_list [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## COLON asm_operands COLON asm_operands COLON asm_flags
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 481, spurious reduction of production asm_flags -> string_literals_list 
##

# Let's ignore the possibility of concatenating string literals.
# We are in the clobber list (asm_flags).
# Either we extend it, or we terminate it with RPAREN.

Ill-formed assembly statement.
Up to this point, a list of clobbered resources has been recognized:
  $0
If this list is complete,
then at this point, a closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE ASM LPAREN STRING_LITERAL COLON STRING_LITERAL LPAREN CONSTANT RPAREN XOR_ASSIGN
##
## Ends in an error in state: 477.
##
## asm_arguments -> COLON asm_operands . [ RPAREN ]
## asm_arguments -> COLON asm_operands . COLON asm_operands [ RPAREN ]
## asm_arguments -> COLON asm_operands . COLON asm_operands COLON asm_flags [ RPAREN ]
##
## The known suffix of the stack is as follows:
## COLON asm_operands
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 469, spurious reduction of production asm_operands -> asm_operands_ne 
##

# We have seen one COLON, hence the outputs. (The list of outputs may be empty.)

Ill-formed assembly statement.
Up to this point, a list of outputs has been recognized:
  $0
If this list is complete,
then at this point, one of the following is expected:
  a colon ':', followed with a list of inputs; or
  a closing parenthesis ')'.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE ASM LPAREN STRING_LITERAL COLON COLON XOR_ASSIGN
##
## Ends in an error in state: 479.
##
## asm_arguments -> COLON asm_operands COLON asm_operands . [ RPAREN ]
## asm_arguments -> COLON asm_operands COLON asm_operands . COLON asm_flags [ RPAREN ]
##
## The known suffix of the stack is as follows:
## COLON asm_operands COLON asm_operands
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 478, spurious reduction of production asm_operands -> 
##

# We have seen two COLONs, hence the outputs and inputs. (The list of inputs may be empty.)

# clang requests a closing parenthesis. gcc requests a string literal.

Ill-formed assembly statement.
Up to this point, a list of outputs and a list of inputs have been recognized:
  $2
  $0
If the latter list is complete,
then at this point, one of the following is expected:
  a colon ':', followed with a list of clobbered resources; or
  a closing parenthesis ')'.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE ASM LPAREN STRING_LITERAL COLON LBRACK PRE_NAME VAR_NAME RBRACK XOR_ASSIGN
##
## Ends in an error in state: 472.
##
## asm_operand -> asm_op_name . string_literals_list LPAREN expression RPAREN [ RPAREN COMMA COLON ]
##
## The known suffix of the stack is as follows:
## asm_op_name
##

# Example of asm_operand: [oldval]"=r"(res)
# We have seen an asm_op_name, we now expect a string literal list.
# "=r" is an example of a constraint.

Ill-formed assembly operand.
At this point, a string literal, representing a constraint, is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE ASM LPAREN STRING_LITERAL COLON LBRACK PRE_NAME VAR_NAME XOR_ASSIGN
##
## Ends in an error in state: 467.
##
## asm_op_name -> LBRACK general_identifier . RBRACK [ STRING_LITERAL ]
##
## The known suffix of the stack is as follows:
## LBRACK general_identifier
##

Ill-formed assembly operand.
At this point, a closing bracket ']' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE ASM LPAREN STRING_LITERAL COLON LBRACK XOR_ASSIGN
##
## Ends in an error in state: 466.
##
## asm_op_name -> LBRACK . general_identifier RBRACK [ STRING_LITERAL ]
##
## The known suffix of the stack is as follows:
## LBRACK
##

Ill-formed assembly operand.
At this point, an identifier is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE ASM LPAREN STRING_LITERAL COLON STRING_LITERAL LPAREN CONSTANT RPAREN COMMA XOR_ASSIGN
##
## Ends in an error in state: 470.
##
## asm_operands_ne -> asm_operands_ne COMMA . asm_operand [ RPAREN COMMA COLON ]
##
## The known suffix of the stack is as follows:
## asm_operands_ne COMMA
##

# clang and gcc request a string literal (which is incomplete).

Ill-formed assembly statement.
At this point, an assembly operand is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE ASM LPAREN STRING_LITERAL COLON STRING_LITERAL LPAREN PRE_NAME VAR_NAME SEMICOLON
##
## Ends in an error in state: 475.
##
## asm_operand -> asm_op_name string_literals_list LPAREN expression . RPAREN [ RPAREN COMMA COLON ]
## expression -> expression . COMMA assignment_expression [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## asm_op_name string_literals_list LPAREN expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 87, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
## In state 145, spurious reduction of production assignment_expression -> conditional_expression 
## In state 149, spurious reduction of production expression -> assignment_expression 
##

Ill-formed assembly operand.
Up to this point, an expression has been recognized:
  $0
If this expression is complete,
then at this point, a closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE ASM LPAREN STRING_LITERAL COLON STRING_LITERAL LPAREN XOR_ASSIGN
##
## Ends in an error in state: 474.
##
## asm_operand -> asm_op_name string_literals_list LPAREN . expression RPAREN [ RPAREN COMMA COLON ]
##
## The known suffix of the stack is as follows:
## asm_op_name string_literals_list LPAREN
##

Ill-formed assembly operand.
At this point, an expression is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE ASM LPAREN STRING_LITERAL COLON STRING_LITERAL XOR_ASSIGN
##
## Ends in an error in state: 473.
##
## asm_operand -> asm_op_name string_literals_list . LPAREN expression RPAREN [ RPAREN COMMA COLON ]
## string_literals_list -> string_literals_list . STRING_LITERAL [ STRING_LITERAL LPAREN ]
##
## The known suffix of the stack is as follows:
## asm_op_name string_literals_list
##

# If we disregard the concatenation of string literals, then
# at this point, we expect LPAREN.

Ill-formed assembly operand.
At this point, an opening parenthesis '(',
followed with an expression and a closing parenthesis ')', is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE ASM LPAREN STRING_LITERAL XOR_ASSIGN
##
## Ends in an error in state: 464.
##
## asm_statement -> ASM asm_attributes LPAREN string_literals_list . asm_arguments RPAREN SEMICOLON [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
## string_literals_list -> string_literals_list . STRING_LITERAL [ STRING_LITERAL RPAREN COLON ]
##
## The known suffix of the stack is as follows:
## ASM asm_attributes LPAREN string_literals_list
##
# Expecting either one more string literal, or COLON, or RPAREN.

# clang requests ')'. gcc requests ':' or ')'.

Ill-formed assembly statement.
At this point, one of the following is expected:
  a string literal, representing one more instruction; or
  a colon ':', followed with a list of outputs; or
  a closing parenthesis ')'.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE ASM LPAREN XOR_ASSIGN
##
## Ends in an error in state: 463.
##
## asm_statement -> ASM asm_attributes LPAREN . string_literals_list asm_arguments RPAREN SEMICOLON [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## ASM asm_attributes LPAREN
##

Ill-formed assembly statement.
At this point, a string literal, representing an instruction, is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE BREAK XOR_ASSIGN
##
## Ends in an error in state: 455.
##
## jump_statement -> BREAK . SEMICOLON [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## BREAK
##
translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE CONTINUE XOR_ASSIGN
##
## Ends in an error in state: 450.
##
## jump_statement -> CONTINUE . SEMICOLON [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## CONTINUE
##
translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE DO SEMICOLON WHILE LPAREN PRE_NAME VAR_NAME RPAREN XOR_ASSIGN
##
## Ends in an error in state: 575.
##
## iteration_statement -> save_context do_statement1 WHILE LPAREN expression RPAREN . SEMICOLON [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context do_statement1 WHILE LPAREN expression RPAREN
##
translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE GOTO PRE_NAME VAR_NAME XOR_ASSIGN
##
## Ends in an error in state: 446.
##
## jump_statement -> GOTO general_identifier . SEMICOLON [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## GOTO general_identifier
##
translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE ASM LPAREN STRING_LITERAL RPAREN XOR_ASSIGN
##
## Ends in an error in state: 487.
##
## asm_statement -> ASM asm_attributes LPAREN string_literals_list asm_arguments RPAREN . SEMICOLON [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## ASM asm_attributes LPAREN string_literals_list asm_arguments RPAREN
##

Ill-formed statement.
At this point, a semicolon ';' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE CASE CONSTANT COLON XOR_ASSIGN
##
## Ends in an error in state: 454.
##
## labeled_statement -> CASE conditional_expression COLON . statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## CASE conditional_expression COLON
##
translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE DEFAULT COLON XOR_ASSIGN
##
## Ends in an error in state: 449.
##
## labeled_statement -> DEFAULT COLON . statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## DEFAULT COLON
##
translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE PRE_NAME VAR_NAME COLON XOR_ASSIGN
##
## Ends in an error in state: 503.
##
## labeled_statement -> general_identifier COLON . statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## general_identifier COLON
##

# gcc and clang request an expression, which seems misleading (incomplete).

Ill-formed labeled statement.
At this point, a statement is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE CASE CONSTANT SEMICOLON
##
## Ends in an error in state: 453.
##
## labeled_statement -> CASE conditional_expression . COLON statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## CASE conditional_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 79, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
##

Ill-formed labeled statement.
Up to this point, an expression has been recognized:
  $0
If this expression is complete,
then at this point, a colon ':' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE CASE XOR_ASSIGN
##
## Ends in an error in state: 452.
##
## labeled_statement -> CASE . conditional_expression COLON statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## CASE
##

Ill-formed labeled statement.
At this point, a constant expression is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE DEFAULT XOR_ASSIGN
##
## Ends in an error in state: 448.
##
## labeled_statement -> DEFAULT . COLON statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## DEFAULT
##
translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE DO PRE_NAME TYPEDEF_NAME XOR_ASSIGN
##
## Ends in an error in state: 502.
##
## labeled_statement -> general_identifier . COLON statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## general_identifier
##

# gcc and clang apparently do not allow a TYPEDEF_NAME to be reclassified as a label.

Ill-formed labeled statement.
At this point, a colon ':' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE DO SEMICOLON WHILE LPAREN PRE_NAME VAR_NAME SEMICOLON
##
## Ends in an error in state: 574.
##
## expression -> expression . COMMA assignment_expression [ RPAREN COMMA ]
## iteration_statement -> save_context do_statement1 WHILE LPAREN expression . RPAREN SEMICOLON [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context do_statement1 WHILE LPAREN expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 87, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
## In state 145, spurious reduction of production assignment_expression -> conditional_expression 
## In state 149, spurious reduction of production expression -> assignment_expression 
##

Ill-formed 'do' ... 'while' statement.
Up to this point, an expression has been recognized:
  $0
If this expression is complete,
then at this point, a closing parenthesis ')' and a semicolon ';' are expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE DO SEMICOLON WHILE LPAREN XOR_ASSIGN
##
## Ends in an error in state: 573.
##
## iteration_statement -> save_context do_statement1 WHILE LPAREN . expression RPAREN SEMICOLON [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context do_statement1 WHILE LPAREN
##

Ill-formed 'do' ... 'while' statement.
At this point, an expression is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE DO SEMICOLON WHILE XOR_ASSIGN
##
## Ends in an error in state: 572.
##
## iteration_statement -> save_context do_statement1 WHILE . LPAREN expression RPAREN SEMICOLON [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context do_statement1 WHILE
##

Ill-formed 'do' ... 'while' statement.
At this point, an opening parenthesis '(' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE DO SEMICOLON XOR_ASSIGN
##
## Ends in an error in state: 571.
##
## iteration_statement -> save_context do_statement1 . WHILE LPAREN expression RPAREN SEMICOLON [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context do_statement1
##

# Quite nicely, in this case, there is no doubt that the statement is
# finished. This is not true in general, I think (the statement could
# be an if/then, and we don't know whether it should have an ELSE
# branch) but is true sometimes (e.g. it is not a conditional
# statement, or it is one and we just saw the ELSE branch).

Ill-formed 'do' ... 'while' statement.
At this point, a 'while' keyword is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE DO XOR_ASSIGN
##
## Ends in an error in state: 567.
##
## do_statement1 -> save_context DO . statement [ WHILE ]
##
## The known suffix of the stack is as follows:
## save_context DO
##

# gcc and clang expect an expression.

Ill-formed 'do' ... 'while' statement.
At this point, a statement (the loop body) is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE FOR LPAREN SEMICOLON SEMICOLON RPAREN XOR_ASSIGN
##
## Ends in an error in state: 537.
##
## iteration_statement -> save_context FOR LPAREN for_statement_header optional(expression,SEMICOLON) optional(expression,RPAREN) . statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context FOR LPAREN for_statement_header optional(expression,SEMICOLON) optional(expression,RPAREN)
##

Ill-formed 'for' statement.
At this point, a statement (the loop body) is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE FOR LPAREN SEMICOLON SEMICOLON PRE_NAME VAR_NAME SEMICOLON
##
## Ends in an error in state: 539.
##
## expression -> expression . COMMA assignment_expression [ RPAREN COMMA ]
## optional(expression,RPAREN) -> expression . RPAREN [ WHILE TILDE SWITCH STRING_LITERAL STAR SIZEOF SEMICOLON RETURN PRE_NAME PLUS MINUS LPAREN LBRACE INC IF GOTO FOR DO DEFAULT DEC CONTINUE CONSTANT CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG ASM AND ALIGNOF ]
##
## The known suffix of the stack is as follows:
## expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 87, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
## In state 145, spurious reduction of production assignment_expression -> conditional_expression 
## In state 149, spurious reduction of production expression -> assignment_expression 
##

# The use of optional(expression,RPAREN) tells us that we are in a FOR statement.
# Relying on this is a bit fragile, though.

Ill-formed 'for' statement.
Up to this point, an expression has been recognized:
  $0
If this expression is complete,
then at this point, a closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE FOR LPAREN SEMICOLON SEMICOLON XOR_ASSIGN
##
## Ends in an error in state: 535.
##
## iteration_statement -> save_context FOR LPAREN for_statement_header optional(expression,SEMICOLON) . optional(expression,RPAREN) statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context FOR LPAREN for_statement_header optional(expression,SEMICOLON)
##

# Expecting the third part of the loop header -- the expression
# that tells what happens after each iteration.

Ill-formed 'for' statement.
At this point, an optional expression
  (evaluated after each execution of the loop body),
followed with a closing parenthesis ')', is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE FOR LPAREN SEMICOLON XOR_ASSIGN
##
## Ends in an error in state: 534.
##
## iteration_statement -> save_context FOR LPAREN for_statement_header . optional(expression,SEMICOLON) optional(expression,RPAREN) statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context FOR LPAREN for_statement_header
##

# Expecting the second part of the loop header -- the controlling expression.

Ill-formed 'for' statement.
At this point, an optional expression
  (evaluated before each execution of the loop body),
followed with a semicolon ';', is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE FOR LPAREN PRE_NAME VAR_NAME RPAREN
##
## Ends in an error in state: 541.
##
## expression -> expression . COMMA assignment_expression [ SEMICOLON COMMA ]
## optional(expression,SEMICOLON) -> expression . SEMICOLON [ TILDE STRING_LITERAL STAR SIZEOF SEMICOLON RPAREN PRE_NAME PLUS MINUS LPAREN INC DEC CONSTANT BUILTIN_VA_ARG BUILTIN_OFFSETOF BANG AND ALIGNOF ]
##
## The known suffix of the stack is as follows:
## expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 87, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
## In state 145, spurious reduction of production assignment_expression -> conditional_expression 
## In state 149, spurious reduction of production expression -> assignment_expression 
##

# At the time of writing, optional(expression,SEMICOLON) is used only in FOR
# loops, but it could be used elsewhere in the future. This is a bit fragile.

Ill-formed 'for' statement.
Up to this point, an expression has been recognized:
  $0
If this expression is complete,
then at this point, a semicolon ';' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE FOR LPAREN XOR_ASSIGN
##
## Ends in an error in state: 521.
##
## iteration_statement -> save_context FOR LPAREN . for_statement_header optional(expression,SEMICOLON) optional(expression,RPAREN) statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context FOR LPAREN
##

# gcc and clang say they expect an expression, which is incomplete.

Ill-formed 'for' statement.
At this point, one of the following is expected:
  an optional expression
    (evaluated once at the beginning),
  followed with a semicolon ';'; or
  a declaration.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE FOR XOR_ASSIGN
##
## Ends in an error in state: 520.
##
## iteration_statement -> save_context FOR . LPAREN for_statement_header optional(expression,SEMICOLON) optional(expression,RPAREN) statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context FOR
##

Ill-formed 'for' statement.
At this point, an opening parenthesis '(' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE GOTO XOR_ASSIGN
##
## Ends in an error in state: 445.
##
## jump_statement -> GOTO . general_identifier SEMICOLON [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## GOTO
##

Ill-formed 'goto' statement.
At this point, an identifier (a 'goto' label) is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE DO IF LPAREN CONSTANT RPAREN SEMICOLON ELSE XOR_ASSIGN
##
## Ends in an error in state: 569.
##
## selection_statement -> save_context ifelse_statement1 . statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context ifelse_statement1
##

Ill-formed 'if' ... 'else' statement.
At this point, a statement is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE IF LPAREN PRE_NAME VAR_NAME RPAREN XOR_ASSIGN
##
## Ends in an error in state: 517.
##
## ifelse_statement1 -> IF LPAREN expression RPAREN save_context . statement ELSE [ WHILE TILDE SWITCH STRING_LITERAL STAR SIZEOF SEMICOLON RETURN PRE_NAME PLUS MINUS LPAREN LBRACE INC IF GOTO FOR DO DEFAULT DEC CONTINUE CONSTANT CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG ASM AND ALIGNOF ]
## selection_statement -> save_context IF LPAREN expression RPAREN save_context . statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context IF LPAREN expression RPAREN save_context
##

Ill-formed 'if' statement.
At this point, a statement is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE IF LPAREN PRE_NAME VAR_NAME SEMICOLON
##
## Ends in an error in state: 515.
##
## expression -> expression . COMMA assignment_expression [ RPAREN COMMA ]
## ifelse_statement1 -> IF LPAREN expression . RPAREN save_context statement ELSE [ WHILE TILDE SWITCH STRING_LITERAL STAR SIZEOF SEMICOLON RETURN PRE_NAME PLUS MINUS LPAREN LBRACE INC IF GOTO FOR DO DEFAULT DEC CONTINUE CONSTANT CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG ASM AND ALIGNOF ]
## selection_statement -> save_context IF LPAREN expression . RPAREN save_context statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context IF LPAREN expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 87, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
## In state 145, spurious reduction of production assignment_expression -> conditional_expression 
## In state 149, spurious reduction of production expression -> assignment_expression 
##

Ill-formed 'if' statement.
Up to this point, an expression has been recognized:
  $0
If this expression is complete,
then at this point, a closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE IF LPAREN XOR_ASSIGN
##
## Ends in an error in state: 514.
##
## ifelse_statement1 -> IF LPAREN . expression RPAREN save_context statement ELSE [ WHILE TILDE SWITCH STRING_LITERAL STAR SIZEOF SEMICOLON RETURN PRE_NAME PLUS MINUS LPAREN LBRACE INC IF GOTO FOR DO DEFAULT DEC CONTINUE CONSTANT CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG ASM AND ALIGNOF ]
## selection_statement -> save_context IF LPAREN . expression RPAREN save_context statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context IF LPAREN
##

Ill-formed 'if' statement.
At this point, an expression is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE IF XOR_ASSIGN
##
## Ends in an error in state: 513.
##
## ifelse_statement1 -> IF . LPAREN expression RPAREN save_context statement ELSE [ WHILE TILDE SWITCH STRING_LITERAL STAR SIZEOF SEMICOLON RETURN PRE_NAME PLUS MINUS LPAREN LBRACE INC IF GOTO FOR DO DEFAULT DEC CONTINUE CONSTANT CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG ASM AND ALIGNOF ]
## selection_statement -> save_context IF . LPAREN expression RPAREN save_context statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context IF
##

Ill-formed 'if' statement.
At this point, an opening parenthesis '(' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE SWITCH LPAREN PRE_NAME VAR_NAME RPAREN XOR_ASSIGN
##
## Ends in an error in state: 511.
##
## selection_statement -> save_context SWITCH LPAREN expression RPAREN . statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context SWITCH LPAREN expression RPAREN
##


# Technically, the body of a 'switch' statement is just a statement,
# but in practice, it should be a list of labeled statements, 
# enclosed in braces. (Unless someone is writing a Duff loop...)

# gcc and clang again request an expression...

Ill-formed 'switch' statement.
At this point, a statement is expected.
It usually takes the form of a series of labeled statements,
enclosed within braces '{' and '}'.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE SWITCH LPAREN PRE_NAME VAR_NAME SEMICOLON
##
## Ends in an error in state: 510.
##
## expression -> expression . COMMA assignment_expression [ RPAREN COMMA ]
## selection_statement -> save_context SWITCH LPAREN expression . RPAREN statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context SWITCH LPAREN expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 87, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
## In state 145, spurious reduction of production assignment_expression -> conditional_expression 
## In state 149, spurious reduction of production expression -> assignment_expression 
##

Ill-formed 'switch' statement.
Up to this point, an expression has been recognized:
  $0
If this expression is complete,
then at this point, a closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE SWITCH LPAREN XOR_ASSIGN
##
## Ends in an error in state: 509.
##
## selection_statement -> save_context SWITCH LPAREN . expression RPAREN statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context SWITCH LPAREN
##

Ill-formed 'switch' statement.
At this point, an expression is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE SWITCH XOR_ASSIGN
##
## Ends in an error in state: 508.
##
## selection_statement -> save_context SWITCH . LPAREN expression RPAREN statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context SWITCH
##

Ill-formed 'switch' statement.
At this point, an opening parenthesis '(' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE WHILE LPAREN PRE_NAME VAR_NAME RPAREN XOR_ASSIGN
##
## Ends in an error in state: 495.
##
## iteration_statement -> save_context WHILE LPAREN expression RPAREN . statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context WHILE LPAREN expression RPAREN
##

Ill-formed 'while' statement.
At this point, a statement (the loop body) is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE WHILE LPAREN PRE_NAME VAR_NAME SEMICOLON
##
## Ends in an error in state: 494.
##
## expression -> expression . COMMA assignment_expression [ RPAREN COMMA ]
## iteration_statement -> save_context WHILE LPAREN expression . RPAREN statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context WHILE LPAREN expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 87, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
## In state 145, spurious reduction of production assignment_expression -> conditional_expression 
## In state 149, spurious reduction of production expression -> assignment_expression 
##

Ill-formed 'while' statement.
Up to this point, an expression has been recognized:
  $0
If this expression is complete,
then at this point, a closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE WHILE LPAREN XOR_ASSIGN
##
## Ends in an error in state: 493.
##
## iteration_statement -> save_context WHILE LPAREN . expression RPAREN statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context WHILE LPAREN
##

Ill-formed 'while' statement.
At this point, an expression is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE WHILE XOR_ASSIGN
##
## Ends in an error in state: 492.
##
## iteration_statement -> save_context WHILE . LPAREN expression RPAREN statement [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context WHILE
##

Ill-formed 'while' statement.
At this point, an opening parenthesis '(' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE XOR_ASSIGN
##
## Ends in an error in state: 436.
##
## block_item_list -> option(block_item_list) . block_item [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
## compound_statement -> save_context LBRACE option(block_item_list) . RBRACE [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN EOF ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## save_context LBRACE option(block_item_list)
##
# We are possibly at the end of a block.
#
# Note that, because we have used %on_error_reduce to consider some
# statements as complete even when they could be continued with ELSE,
# we may end up here even though ELSE is permitted. There is nothing
# we can do about it. We just omit this permitted continuation in our
# message.

# clang and gcc say an expression is expected.

At this point, one of the following is expected:
  a declaration; or
  a statement; or
  a pragma; or
  a closing brace '}'.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE RETURN XOR_ASSIGN
##
## Ends in an error in state: 437.
##
## jump_statement -> RETURN . option(expression) SEMICOLON [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN ENUM ELSE DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## RETURN
##

# clang and gcc expect an expression.

Ill-formed 'return' statement.
At this point, one of the following is expected:
  an expression; or
  a semicolon ';'.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE STRING_LITERAL RPAREN
##
## Ends in an error in state: 440.
##
## expression -> expression . COMMA assignment_expression [ SEMICOLON COMMA ]
## option(expression) -> expression . [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production primary_expression -> string_literals_list 
## In state 82, spurious reduction of production postfix_expression -> primary_expression 
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 87, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
## In state 145, spurious reduction of production assignment_expression -> conditional_expression 
## In state 149, spurious reduction of production expression -> assignment_expression 
##

Up to this point, an expression has been recognized:
  $0
If this expression is complete,
then at this point, a semicolon ';' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE PRE_NAME TYPEDEF_NAME XOR_ASSIGN
##
## Ends in an error in state: 578.
##
## declaration_specifiers(declaration(block_item)) -> typedef_name . list(declaration_specifier_no_type) [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers_typedef -> typedef_name . list(declaration_specifier_no_type) TYPEDEF list(declaration_specifier_no_type) [ STAR SEMICOLON PRE_NAME LPAREN ]
## general_identifier -> typedef_name . [ COLON ]
##
## The known suffix of the stack is as follows:
## typedef_name
##

# We see a type name "foo" at the beginning of a block_item, it seems.
# This could be the beginning of a declaration, "foo x".
# In that case, we expect a possibly-empty list declaration_specifiers_no_type?,
# which means a list of:
#   storage class specifiers,
#   type qualifiers,
#   function specifiers (i.e., INLINE, but I suspect this is illegal here).
# After this list, we expect init_declarator_list? SEMICOLON.
# The second form, where this could be a typedef, is very exotic; ignore it.
# This could also be a labeled statement, in which case we expect a colon.
#   This case sounds rather unlikely. Let's omit it.

# We simplify "a list of init declarators" to "an init declarator".

A type identifier has been recognized.
Assuming this is the beginning of a declaration,
at this point, one of the following is expected:
  a storage class specifier; or
  a type qualifier; or
  an init declarator, followed with a semicolon ';'.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME RPAREN LBRACE PRE_NAME VAR_NAME COMMA XOR_ASSIGN
##
## Ends in an error in state: 144.
##
## expression -> expression COMMA . assignment_expression [ SEMICOLON RPAREN RBRACK COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expression COMMA
##

Ill-formed use of the sequencing operator ','.
At this point, an expression is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME COMMA PRE_NAME VAR_NAME RPAREN
##
## Ends in an error in state: 555.
##
## init_declarator_list -> init_declarator_list . COMMA init_declarator [ SEMICOLON COMMA ]
## option(init_declarator_list) -> init_declarator_list . [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## init_declarator_list
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 263, spurious reduction of production declarator_noattrend -> direct_declarator 
## In state 563, spurious reduction of production declare_varname(declarator_noattrend) -> declarator_noattrend 
## In state 558, spurious reduction of production save_context -> 
## In state 559, spurious reduction of production attribute_specifier_list -> 
## In state 560, spurious reduction of production init_declarator -> declare_varname(declarator_noattrend) save_context attribute_specifier_list 
## In state 557, spurious reduction of production init_declarator_list -> init_declarator_list COMMA init_declarator 
##

Up to this point, a list of declarators has been recognized:
  $0
If this list is complete,
then at this point, a semicolon ';' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME COMMA XOR_ASSIGN
##
## Ends in an error in state: 556.
##
## init_declarator_list -> init_declarator_list COMMA . init_declarator [ SEMICOLON COMMA ]
##
## The known suffix of the stack is as follows:
## init_declarator_list COMMA
##

Ill-formed declaration.
At this point, an init declarator is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ LBRACE DOT PRE_NAME VAR_NAME EQ ALIGNAS
##
## Ends in an error in state: 374.
##
## initializer_list -> option(designation) . c_initializer [ RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## option(designation)
##
translation_unit_file: INT PRE_NAME VAR_NAME EQ LBRACE PRE_NAME VAR_NAME COMMA DOT PRE_NAME VAR_NAME EQ ALIGNAS
##
## Ends in an error in state: 378.
##
## initializer_list -> initializer_list COMMA option(designation) . c_initializer [ RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## initializer_list COMMA option(designation)
##

Ill-formed initializer list.
At this point, an initializer is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ LBRACE DOT PRE_NAME VAR_NAME XOR_ASSIGN
##
## Ends in an error in state: 381.
##
## designation -> designator_list . EQ [ TILDE STRING_LITERAL STAR SIZEOF PRE_NAME PLUS MINUS LPAREN LBRACE INC DEC CONSTANT BUILTIN_VA_ARG BUILTIN_OFFSETOF BANG AND ALIGNOF ]
## option(designator_list) -> designator_list . [ LBRACK DOT ]
##
## The known suffix of the stack is as follows:
## designator_list
##

# We are expecting either one more designator,
# or an EQ sign (which marks the end of the designation).

Ill-formed designation.
Up to this point, a list of designators has been recognized:
  $0
If this list is complete,
then at this point, an equals sign '=' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ LBRACE DOT XOR_ASSIGN
##
## Ends in an error in state: 334.
##
## designator -> DOT . general_identifier [ RPAREN LBRACK EQ DOT ]
##
## The known suffix of the stack is as follows:
## DOT
##

# clang gives examples of designators.

Ill-formed designator.
At this point, the name of a struct or union member is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ LBRACE LBRACK PRE_NAME VAR_NAME SEMICOLON
##
## Ends in an error in state: 332.
##
## designator -> LBRACK conditional_expression . RBRACK [ RPAREN LBRACK EQ DOT ]
##
## The known suffix of the stack is as follows:
## LBRACK conditional_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 79, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
##

Ill-formed designator.
Up to this point, an opening bracket and an expression have been recognized:
  $1 $0
If this expression is complete,
then at this point, a closing bracket ']' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ LBRACE LBRACK XOR_ASSIGN
##
## Ends in an error in state: 331.
##
## designator -> LBRACK . conditional_expression RBRACK [ RPAREN LBRACK EQ DOT ]
##
## The known suffix of the stack is as follows:
## LBRACK
##

Ill-formed designator.
At this point, a constant expression is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ LBRACE PRE_NAME VAR_NAME COMMA XOR_ASSIGN
##
## Ends in an error in state: 377.
##
## initializer_list -> initializer_list COMMA . option(designation) c_initializer [ RBRACE COMMA ]
## option(COMMA) -> COMMA . [ RBRACE ]
##
## The known suffix of the stack is as follows:
## initializer_list COMMA
##

# This could be a trailing comma, in which case a closing brace is legal.
# Or, this comma could announce a new option(designation) c_initializer.

Ill-formed initializer list.
At this point, one of the following is expected:
  an optional designation, followed with an initializer; or
  a closing brace '}'.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ LBRACE CONSTANT SEMICOLON
##
## Ends in an error in state: 376.
##
## c_initializer -> LBRACE initializer_list . option(COMMA) RBRACE [ SEMICOLON RBRACE COMMA ]
## initializer_list -> initializer_list . COMMA option(designation) c_initializer [ RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## LBRACE initializer_list
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 87, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
## In state 145, spurious reduction of production assignment_expression -> conditional_expression 
## In state 380, spurious reduction of production c_initializer -> assignment_expression 
## In state 386, spurious reduction of production initializer_list -> option(designation) c_initializer 
##

# Omitting the fact that the closing brace can be preceded with a comma.

Ill-formed initializer.
Up to this point, a list of initializers has been recognized:
  $0
If this list is complete,
then at this point, a closing brace '}' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ LBRACE XOR_ASSIGN
##
## Ends in an error in state: 375.
##
## c_initializer -> LBRACE . initializer_list option(COMMA) RBRACE [ SEMICOLON RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

# An initializer list is expected.
# Hence, an initializer is expected.

# clang and gcc expect an expression (incomplete).

Ill-formed initializer.
At this point, an optional designation,
followed with an initializer, is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME EQ XOR_ASSIGN
##
## Ends in an error in state: 561.
##
## init_declarator -> declare_varname(declarator_noattrend) save_context attribute_specifier_list EQ . c_initializer [ SEMICOLON COMMA ]
##
## The known suffix of the stack is as follows:
## declare_varname(declarator_noattrend) save_context attribute_specifier_list EQ
##

# clang and gcc expect an expression (incomplete).

Ill-formed init declarator.
At this point, an initializer is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LBRACK CONSTANT SEMICOLON
##
## Ends in an error in state: 251.
##
## optional(assignment_expression,RBRACK) -> assignment_expression . RBRACK [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG LBRACK LBRACE INT INLINE FLOAT EXTERN EQ ENUM DOUBLE CONST COMMA COLON CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## assignment_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 87, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
## In state 145, spurious reduction of production assignment_expression -> conditional_expression 
##

# At the time of writing, optional(expression,RBRACK) is used only in direct
# (possibly abstract) declarators, but it could be used elsewhere in the future.
# This is a bit fragile.

# Ill-formed direct declarator or direct abstract declarator.

Up to this point, an expression has been recognized:
  $0
If this expression is complete,
then at this point, a closing bracket ']' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN PRE_NAME VAR_NAME COMMA XOR_ASSIGN
##
## Ends in an error in state: 290.
##
## identifier_list -> identifier_list COMMA . PRE_NAME VAR_NAME [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## identifier_list COMMA
##

# Strangely, gcc requests ')'.

Ill-formed K&R function definition.
At this point, an identifier is expected.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN PRE_NAME VAR_NAME COMMA PRE_NAME TYPEDEF_NAME
##
## Ends in an error in state: 291.
##
## identifier_list -> identifier_list COMMA PRE_NAME . VAR_NAME [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## identifier_list COMMA PRE_NAME
##

Ill-formed K&R function definition.
The following type name is used as a K&R parameter name:
  $0

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN PRE_NAME VAR_NAME RPAREN INT XOR_ASSIGN
##
## Ends in an error in state: 596.
##
## declaration_specifiers(declaration(block_item)) -> type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) . [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_typedef_name) -> list(declaration_specifier_no_typedef_name) . declaration_specifier_no_typedef_name [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC STAR SIGNED SHORT SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG INT INLINE FLOAT EXTERN ENUM DOUBLE CONST CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name)
##
translation_unit_file: INT PRE_NAME VAR_NAME LPAREN PRE_NAME VAR_NAME RPAREN VOLATILE INT XOR_ASSIGN
##
## Ends in an error in state: 601.
##
## declaration_specifiers(declaration(block_item)) -> rlist(declaration_specifier_no_type) type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) . [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_typedef_name) -> list(declaration_specifier_no_typedef_name) . declaration_specifier_no_typedef_name [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC STAR SIGNED SHORT SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG INT INLINE FLOAT EXTERN ENUM DOUBLE CONST CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## rlist(declaration_specifier_no_type) type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name)
##
translation_unit_file: INT PRE_NAME VAR_NAME LPAREN PRE_NAME VAR_NAME RPAREN PRE_NAME TYPEDEF_NAME XOR_ASSIGN
##
## Ends in an error in state: 594.
##
## declaration_specifiers(declaration(block_item)) -> typedef_name list(declaration_specifier_no_type) . [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . storage_class_specifier_no_typedef [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . type_qualifier_noattr [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . function_specifier [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . attribute_specifier [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## typedef_name list(declaration_specifier_no_type)
##
translation_unit_file: INT PRE_NAME VAR_NAME LPAREN PRE_NAME VAR_NAME RPAREN VOLATILE PRE_NAME TYPEDEF_NAME XOR_ASSIGN
##
## Ends in an error in state: 599.
##
## declaration_specifiers(declaration(block_item)) -> rlist(declaration_specifier_no_type) typedef_name list(declaration_specifier_no_type) . [ STAR SEMICOLON PRE_NAME LPAREN ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . storage_class_specifier_no_typedef [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . type_qualifier_noattr [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . function_specifier [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
## list(declaration_specifier_no_type) -> list(declaration_specifier_no_type) . attribute_specifier [ VOLATILE STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## rlist(declaration_specifier_no_type) typedef_name list(declaration_specifier_no_type)
##

# We omit the case of the empty list of declarators
# We omit the case of successive primitive type specifiers

Ill-formed K&R parameter declaration.
At this point, one of the following is expected:
  a storage class specifier; or
  a type qualifier; or
  a list of declarators.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN PRE_NAME VAR_NAME RPAREN VOLATILE XOR_ASSIGN
##
## Ends in an error in state: 597.
##
## declaration_specifiers(declaration(block_item)) -> rlist(declaration_specifier_no_type) . typedef_name list(declaration_specifier_no_type) [ STAR SEMICOLON PRE_NAME LPAREN ]
## declaration_specifiers(declaration(block_item)) -> rlist(declaration_specifier_no_type) . type_specifier_no_typedef_name list(declaration_specifier_no_typedef_name) [ STAR SEMICOLON PRE_NAME LPAREN ]
##
## The known suffix of the stack is as follows:
## rlist(declaration_specifier_no_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 222, spurious reduction of production rlist(declaration_specifier_no_type) -> type_qualifier_noattr 
##

Ill-formed K&R parameter declaration.
At this point, one of the following is expected:
  a storage class specifier; or
  a type qualifier; or
  a type specifier.

# ------------------------------------------------------------------------------

translation_unit_file: VOID PRE_NAME TYPEDEF_NAME PACKED LPAREN CONSTANT RPAREN XOR_ASSIGN
##
## Ends in an error in state: 610.
##
## attribute_specifier_list -> attribute_specifier . attribute_specifier_list [ SEMICOLON LBRACE EQ COMMA ]
## rlist(declaration_specifier_no_type) -> attribute_specifier . [ VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT SIGNED SHORT PRE_NAME LONG INT FLOAT ENUM DOUBLE CHAR ]
## rlist(declaration_specifier_no_type) -> attribute_specifier . rlist(declaration_specifier_no_type) [ VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT SIGNED SHORT PRE_NAME LONG INT FLOAT ENUM DOUBLE CHAR ]
##
## The known suffix of the stack is as follows:
## attribute_specifier
##

# We have just parsed a list of attribute specifiers, but we cannot
# print it because it is not available. We do not know whether it is
# part of the declaration or whether it is part of the first K&R parameter
# declaration.

# We omit the possibility of one more attribute specifier

Ill-formed declaration or function definition.
Up to this point, a list of attribute specifiers has been recognized.
If this is a declaration,
  then at this point, a semicolon ';' is expected.
If this is a function definition,
  then at this point, an opening brace '{' is expected (for the function body).
If this is the parameter declaration of a K&R function definition,
  then at this point, one of the following is expected:
    a storage class specifier; or
    a type qualifier; or
    a type specifier.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT COMMA XOR_ASSIGN
##
## Ends in an error in state: 238.
##
## parameter_list -> parameter_list COMMA . parameter_declaration [ RPAREN COMMA ]
## parameter_type_list -> parameter_list COMMA . ELLIPSIS [ RPAREN ]
##
## The known suffix of the stack is as follows:
## parameter_list COMMA
##

At this point, one of the following is expected:
  a parameter declaration; or
  an ellipsis '...'.

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN INT PRE_NAME VAR_NAME SEMICOLON
##
## Ends in an error in state: 237.
##
## parameter_list -> parameter_list . COMMA parameter_declaration [ RPAREN COMMA ]
## parameter_type_list -> parameter_list . [ RPAREN ]
## parameter_type_list -> parameter_list . COMMA ELLIPSIS [ RPAREN ]
##
## The known suffix of the stack is as follows:
## parameter_list
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 263, spurious reduction of production declarator_noattrend -> direct_declarator 
## In state 268, spurious reduction of production attribute_specifier_list -> 
## In state 269, spurious reduction of production declarator -> declarator_noattrend attribute_specifier_list 
## In state 285, spurious reduction of production declare_varname(declarator) -> declarator 
## In state 284, spurious reduction of production parameter_declaration -> declaration_specifiers(parameter_declaration) declare_varname(declarator) 
## In state 245, spurious reduction of production parameter_list -> parameter_declaration 
##

# We omit the possibility of an ellipsis.
# It can be understood as part of the "if this list is complete..." hypothesis.

# Strangely, gcc is not bothered by the last SEMICOLON,
# but complains that this is a "forward declaration" of the parameter.

Up to this point, a list of parameter declarations has been recognized:
  $0
If this list is complete,
then at this point, a closing parenthesis ')' is expected.

# ------------------------------------------------------------------------------

translation_unit_file: PRE_NAME VAR_NAME
##
## Ends in an error in state: 16.
##
## typedef_name -> PRE_NAME . TYPEDEF_NAME [ VOLATILE TYPEDEF STATIC STAR SEMICOLON RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LBRACK INLINE EXTERN CONST COMMA COLON AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## PRE_NAME
##

# This can only happen in a declaration

Ill-formed declaration.
The following identifier is used as a type, but has not been defined as such:
  $0

# ------------------------------------------------------------------------------

translation_unit_file: INT PRE_NAME VAR_NAME LPAREN PRE_NAME VAR_NAME RPAREN INT SEMICOLON XOR_ASSIGN
##
## Ends in an error in state: 606.
##
## declaration_list -> declaration_list . kr_param_declaration [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC SIGNED SHORT RESTRICT REGISTER PRE_NAME PACKED NORETURN LONG LBRACE INT INLINE FLOAT EXTERN ENUM DOUBLE CONST CHAR AUTO ATTRIBUTE ALIGNAS ]
## function_definition1 -> declaration_specifiers(declaration(external_declaration)) declare_varname(declarator_noattrend) save_context declaration_list . [ LBRACE ]
##
## The known suffix of the stack is as follows:
## declaration_specifiers(declaration(external_declaration)) declare_varname(declarator_noattrend) save_context declaration_list
##
# clang requests the function body; gcc requests a declaration :-)

Ill-formed K&R function definition.
At this point, one of the following is expected:
  a declaration; or
  an opening brace '{' (for the function body).

#------------------------------------------------------------------------------

translation_unit_file: PACKED LPAREN BUILTIN_OFFSETOF XOR_ASSIGN
##
## Ends in an error in state: 52.
##
## postfix_expression -> BUILTIN_OFFSETOF . LPAREN type_name COMMA general_identifier RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
## postfix_expression -> BUILTIN_OFFSETOF . LPAREN type_name COMMA general_identifier designator_list RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## BUILTIN_OFFSETOF
##

Ill-formed __builtin_offsetof.
At this point, an opening parenthesis '(' is expected.

#------------------------------------------------------------------------------

translation_unit_file: PACKED LPAREN BUILTIN_OFFSETOF LPAREN XOR_ASSIGN
##
## Ends in an error in state: 53.
##
## postfix_expression -> BUILTIN_OFFSETOF LPAREN . type_name COMMA general_identifier RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
## postfix_expression -> BUILTIN_OFFSETOF LPAREN . type_name COMMA general_identifier designator_list RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## BUILTIN_OFFSETOF LPAREN
##

Ill-formed __builtin_offsetof.
At this point, a struct or union name is expected.

#------------------------------------------------------------------------------

translation_unit_file: PACKED LPAREN BUILTIN_OFFSETOF LPAREN VOID XOR_ASSIGN
##
## Ends in an error in state: 326.
##
## postfix_expression -> BUILTIN_OFFSETOF LPAREN type_name . COMMA general_identifier RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
## postfix_expression -> BUILTIN_OFFSETOF LPAREN type_name . COMMA general_identifier designator_list RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## BUILTIN_OFFSETOF LPAREN type_name
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 67, spurious reduction of production specifier_qualifier_list(type_name) -> type_specifier_no_typedef_name list(specifier_qualifier_no_typedef_name) 
## In state 314, spurious reduction of production option(abstract_declarator(type_name)) -> 
## In state 320, spurious reduction of production type_name -> specifier_qualifier_list(type_name) option(abstract_declarator(type_name)) 
##

Ill-formed __builtin_offsetof.
At this point, a colon ',' is expected

#------------------------------------------------------------------------------

translation_unit_file: PACKED LPAREN BUILTIN_OFFSETOF LPAREN VOID COMMA XOR_ASSIGN
##
## Ends in an error in state: 327.
##
## postfix_expression -> BUILTIN_OFFSETOF LPAREN type_name COMMA . general_identifier RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
## postfix_expression -> BUILTIN_OFFSETOF LPAREN type_name COMMA . general_identifier designator_list RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## BUILTIN_OFFSETOF LPAREN type_name COMMA
##

Ill-formed __builtin_offsetof.
At this point, a member-designator is expected.

#------------------------------------------------------------------------------

translation_unit_file: PACKED LPAREN BUILTIN_OFFSETOF LPAREN VOID COMMA PRE_NAME TYPEDEF_NAME XOR_ASSIGN
##
## Ends in an error in state: 328.
##
## postfix_expression -> BUILTIN_OFFSETOF LPAREN type_name COMMA general_identifier . RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
## postfix_expression -> BUILTIN_OFFSETOF LPAREN type_name COMMA general_identifier . designator_list RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## BUILTIN_OFFSETOF LPAREN type_name COMMA general_identifier
##

Ill-formed __builtin_offsetof.
At this point, a member-designator is expected.

#------------------------------------------------------------------------------

translation_unit_file: PACKED LPAREN BUILTIN_OFFSETOF LPAREN VOID COMMA PRE_NAME TYPEDEF_NAME LBRACK STRING_LITERAL RBRACK XOR_ASSIGN
##
## Ends in an error in state: 337.
##
## option(designator_list) -> designator_list . [ LBRACK DOT ]
## postfix_expression -> BUILTIN_OFFSETOF LPAREN type_name COMMA general_identifier designator_list . RPAREN [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RBRACK RBRACE QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA COLON BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## BUILTIN_OFFSETOF LPAREN type_name COMMA general_identifier designator_list
##


Ill-formed __builtin_offsetof.
At this point, a member-designator is expected.
# ------------------------------------------------------------------------------

translation_unit_file: STATIC_ASSERT XOR_ASSIGN
##
## Ends in an error in state: 76.
##
## static_assert_declaration -> STATIC_ASSERT . LPAREN conditional_expression COMMA string_literals_list RPAREN SEMICOLON [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN EOF ENUM DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## STATIC_ASSERT
##

Ill-formed _Static_assert.
At this point, an opening parenthesis '(' is expected.

#------------------------------------------------------------------------------

translation_unit_file: STATIC_ASSERT LPAREN XOR_ASSIGN
##
## Ends in an error in state: 77.
##
## static_assert_declaration -> STATIC_ASSERT LPAREN . conditional_expression COMMA string_literals_list RPAREN SEMICOLON [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN EOF ENUM DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## STATIC_ASSERT LPAREN
##

Ill-formed _Static_assert.
At this point, a constant expression is expected.

#------------------------------------------------------------------------------

translation_unit_file: STATIC_ASSERT LPAREN STRING_LITERAL XOR_ASSIGN
##
## Ends in an error in state: 167.
##
## static_assert_declaration -> STATIC_ASSERT LPAREN conditional_expression . COMMA string_literals_list RPAREN SEMICOLON [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN EOF ENUM DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## STATIC_ASSERT LPAREN conditional_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production primary_expression -> string_literals_list 
## In state 82, spurious reduction of production postfix_expression -> primary_expression 
## In state 83, spurious reduction of production unary_expression -> postfix_expression 
## In state 79, spurious reduction of production cast_expression -> unary_expression 
## In state 110, spurious reduction of production multiplicative_expression -> cast_expression 
## In state 104, spurious reduction of production additive_expression -> multiplicative_expression 
## In state 123, spurious reduction of production shift_expression -> additive_expression 
## In state 100, spurious reduction of production relational_expression -> shift_expression 
## In state 116, spurious reduction of production equality_expression -> relational_expression 
## In state 132, spurious reduction of production and_expression -> equality_expression 
## In state 140, spurious reduction of production exclusive_or_expression -> and_expression 
## In state 141, spurious reduction of production inclusive_or_expression -> exclusive_or_expression 
## In state 142, spurious reduction of production logical_and_expression -> inclusive_or_expression 
## In state 126, spurious reduction of production logical_or_expression -> logical_and_expression 
## In state 124, spurious reduction of production conditional_expression -> logical_or_expression 
##

Ill-formed _Static_assert.
At this point, a comma ',' is expected.

#------------------------------------------------------------------------------

translation_unit_file: STATIC_ASSERT LPAREN STRING_LITERAL COMMA XOR_ASSIGN
##
## Ends in an error in state: 168.
##
## static_assert_declaration -> STATIC_ASSERT LPAREN conditional_expression COMMA . string_literals_list RPAREN SEMICOLON [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN EOF ENUM DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## STATIC_ASSERT LPAREN conditional_expression COMMA
##

Ill-formed _Static_assert.
At this point, a string literal is expected.

#------------------------------------------------------------------------------

translation_unit_file: STATIC_ASSERT LPAREN STRING_LITERAL COMMA STRING_LITERAL XOR_ASSIGN
##
## Ends in an error in state: 169.
##
## static_assert_declaration -> STATIC_ASSERT LPAREN conditional_expression COMMA string_literals_list . RPAREN SEMICOLON [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN EOF ENUM DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
## string_literals_list -> string_literals_list . STRING_LITERAL [ STRING_LITERAL RPAREN ]
##
## The known suffix of the stack is as follows:
## STATIC_ASSERT LPAREN conditional_expression COMMA string_literals_list
##

Ill-formed _Static_assert.
At this point, a closing parenthesis ')' is expected.

#------------------------------------------------------------------------------

translation_unit_file: STATIC_ASSERT LPAREN STRING_LITERAL COMMA STRING_LITERAL RPAREN XOR_ASSIGN
##
## Ends in an error in state: 170.
##
## static_assert_declaration -> STATIC_ASSERT LPAREN conditional_expression COMMA string_literals_list RPAREN . SEMICOLON [ WHILE VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF TILDE SWITCH STRUCT STRING_LITERAL STATIC_ASSERT STATIC STAR SIZEOF SIGNED SHORT SEMICOLON RETURN RESTRICT REGISTER RBRACE PRE_NAME PRAGMA PLUS PACKED NORETURN MINUS LPAREN LONG LBRACE INT INLINE INC IF GOTO FOR FLOAT EXTERN EOF ENUM DOUBLE DO DEFAULT DEC CONTINUE CONSTANT CONST CHAR CASE BUILTIN_VA_ARG BUILTIN_OFFSETOF BREAK BANG AUTO ATTRIBUTE ASM AND ALIGNOF ALIGNAS ]
##
## The known suffix of the stack is as follows:
## STATIC_ASSERT LPAREN conditional_expression COMMA string_literals_list RPAREN
##

Ill-formed _Static_assert.
At this point, a semicolon ';' is expected.

#------------------------------------------------------------------------------

translation_unit_file: ALIGNAS LPAREN PRE_NAME XOR_ASSIGN
##
## Ends in an error in state: 29.
##
## primary_expression -> PRE_NAME . VAR_NAME [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RPAREN RIGHT_ASSIGN RIGHT QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
## typedef_name -> PRE_NAME . TYPEDEF_NAME [ VOLATILE TYPEDEF STATIC STAR SEMICOLON RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LBRACK INLINE EXTERN CONST COMMA AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## PRE_NAME
##
translation_unit_file: ALIGNAS LPAREN VOID LPAREN VOID LPAREN PRE_NAME XOR_ASSIGN
##
## Ends in an error in state: 244.
##
## declarator_identifier -> PRE_NAME . low_prec TYPEDEF_NAME [ RPAREN PACKED LPAREN LBRACK ATTRIBUTE ALIGNAS ]
## declarator_identifier -> PRE_NAME . VAR_NAME [ RPAREN PACKED LPAREN LBRACK ATTRIBUTE ALIGNAS ]
## typedef_name -> PRE_NAME . TYPEDEF_NAME [ VOLATILE STATIC STAR RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LBRACK INLINE EXTERN CONST COMMA AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## PRE_NAME
##
translation_unit_file: UNION PRE_NAME XOR_ASSIGN
##
## Ends in an error in state: 40.
##
## general_identifier -> PRE_NAME . VAR_NAME [ XOR_ASSIGN VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF SUB_ASSIGN STRUCT STATIC STAR SLASH SIGNED SHORT SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RESTRICT REGISTER RBRACK RBRACE QUESTION PTR PRE_NAME PLUS PERCENT PACKED OR_ASSIGN NORETURN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LONG LEQ LEFT_ASSIGN LEFT LBRACK LBRACE INT INLINE INC HAT GT GEQ FLOAT EXTERN EQEQ EQ ENUM DOUBLE DOT DIV_ASSIGN DEC CONST COMMA COLON CHAR BARBAR BAR AUTO ATTRIBUTE AND_ASSIGN ANDAND AND ALIGNAS ADD_ASSIGN ]
## typedef_name -> PRE_NAME . TYPEDEF_NAME [ XOR_ASSIGN VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL TYPEDEF SUB_ASSIGN STRUCT STATIC STAR SLASH SIGNED SHORT SEMICOLON RPAREN RIGHT_ASSIGN RIGHT RESTRICT REGISTER RBRACK RBRACE QUESTION PTR PRE_NAME PLUS PERCENT PACKED OR_ASSIGN NORETURN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LONG LEQ LEFT_ASSIGN LEFT LBRACK LBRACE INT INLINE INC HAT GT GEQ FLOAT EXTERN EQEQ EQ ENUM DOUBLE DOT DIV_ASSIGN DEC CONST COMMA COLON CHAR BARBAR BAR AUTO ATTRIBUTE AND_ASSIGN ANDAND AND ALIGNAS ADD_ASSIGN ]
##
## The known suffix of the stack is as follows:
## PRE_NAME
##
translation_unit_file: VOID PRE_NAME TYPEDEF_NAME LBRACE PRE_NAME XOR_ASSIGN
##
## Ends in an error in state: 442.
##
## general_identifier -> PRE_NAME . VAR_NAME [ COLON ]
## primary_expression -> PRE_NAME . VAR_NAME [ XOR_ASSIGN SUB_ASSIGN STAR SLASH SEMICOLON RIGHT_ASSIGN RIGHT QUESTION PTR PLUS PERCENT OR_ASSIGN NEQ MUL_ASSIGN MOD_ASSIGN MINUS LT LPAREN LEQ LEFT_ASSIGN LEFT LBRACK INC HAT GT GEQ EQEQ EQ DOT DIV_ASSIGN DEC COMMA BARBAR BAR AND_ASSIGN ANDAND AND ADD_ASSIGN ]
## typedef_name -> PRE_NAME . TYPEDEF_NAME [ VOLATILE TYPEDEF STATIC STAR SEMICOLON RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN INLINE EXTERN CONST COLON AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## PRE_NAME
##
translation_unit_file: VOID PRE_NAME TYPEDEF_NAME LPAREN PRE_NAME XOR_ASSIGN
##
## Ends in an error in state: 202.
##
## identifier_list -> PRE_NAME . VAR_NAME [ RPAREN COMMA ]
## typedef_name -> PRE_NAME . TYPEDEF_NAME [ VOLATILE STATIC STAR RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LBRACK INLINE EXTERN CONST COMMA AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## PRE_NAME
##
translation_unit_file: VOID PRE_NAME XOR_ASSIGN
##
## Ends in an error in state: 190.
##
## declarator_identifier -> PRE_NAME . low_prec TYPEDEF_NAME [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG LBRACK LBRACE INT INLINE FLOAT EXTERN EQ ENUM DOUBLE CONST COMMA COLON CHAR AUTO ATTRIBUTE ALIGNAS ]
## declarator_identifier -> PRE_NAME . VAR_NAME [ VOLATILE VOID UNSIGNED UNION UNDERSCORE_BOOL STRUCT STATIC SIGNED SHORT SEMICOLON RPAREN RESTRICT REGISTER PRE_NAME PACKED NORETURN LPAREN LONG LBRACK LBRACE INT INLINE FLOAT EXTERN EQ ENUM DOUBLE CONST COMMA COLON CHAR AUTO ATTRIBUTE ALIGNAS ]
##
## The known suffix of the stack is as follows:
## PRE_NAME
##

# This is not supposed to be possible, since the Lexer can only emit a
# VAR_NAME or a TYPEDEF_NAME after a PRE_NAME

Internal error when printing a syntax error message. Please report.

# ------------------------------------------------------------------------------



# Local Variables:
# mode: shell-script
# End:
