<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<link rel="Start" href="index.html">
<link rel="previous" href="Stats.html">
<link rel="next" href="Formatcil.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Pretty" rel="Chapter" href="Pretty.html">
<link title="Errormsg" rel="Chapter" href="Errormsg.html">
<link title="Clist" rel="Chapter" href="Clist.html">
<link title="Stats" rel="Chapter" href="Stats.html">
<link title="Cil" rel="Chapter" href="Cil.html">
<link title="Formatcil" rel="Chapter" href="Formatcil.html">
<link title="Alpha" rel="Chapter" href="Alpha.html">
<link title="Cillower" rel="Chapter" href="Cillower.html">
<link title="Cfg" rel="Chapter" href="Cfg.html">
<link title="Dataflow" rel="Chapter" href="Dataflow.html">
<link title="Dominators" rel="Chapter" href="Dominators.html"><title>CIL API Documentation (version 1.3.5) : Cil</title>
</head>
<body>
<div class="navbar"><a href="Stats.html">Previous</a>
&nbsp;<a href="index.html">Up</a>
&nbsp;<a href="Formatcil.html">Next</a>
</div>
<center><h1>Module <a href="type_Cil.html">Cil</a></h1></center>
<br>
<pre><span class="keyword">module</span> Cil: <code class="code">sig</code> <a href="Cil.html">..</a> <code class="code">end</code></pre>CIL API Documentation. An html version of this document can be found at 
 http://manju.cs.berkeley.edu/cil.<br>
<hr width="100%">
<pre><span class="keyword">val</span> <a name="VALinitCIL"></a>initCIL : <code class="type">unit -> unit</code></pre><div class="info">
Call this function to perform some initialization. Call if after you have 
 set <a href="Cil.html#VALmsvcMode"><code class="code">Cil.msvcMode</code></a>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcilVersion"></a>cilVersion : <code class="type">string</code></pre><div class="info">
This are the CIL version numbers. A CIL version is a number of the form 
 M.m.r (major, minor and release)<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcilVersionMajor"></a>cilVersionMajor : <code class="type">int</code></pre><pre><span class="keyword">val</span> <a name="VALcilVersionMinor"></a>cilVersionMinor : <code class="type">int</code></pre><pre><span class="keyword">val</span> <a name="VALcilVersionRevision"></a>cilVersionRevision : <code class="type">int</code></pre><br>
This module defines the abstract syntax of CIL. It also provides utility 
 functions for traversing the CIL data structures, and pretty-printing 
 them. The parser for both the GCC and MSVC front-ends can be invoked as 
 <code class="code">Frontc.parse: string -&gt; unit -&gt;</code> <a href="Cil.html#TYPEfile"><code class="code">Cil.file</code></a>. This function must be given 
 the name of a preprocessed C file and will return the top-level data 
 structure that describes a whole source file. By default the parsing and 
 elaboration into CIL is done as for GCC source. If you want to use MSVC 
 source you must set the <a href="Cil.html#VALmsvcMode"><code class="code">Cil.msvcMode</code></a> to <code class="code">true</code> and must also invoke the 
 function <code class="code">Frontc.setMSVCMode: unit -&gt; unit</code>.<br>
<br>
<b>The Abstract Syntax of CIL</b><br>
<br>
The top-level representation of a CIL source file (and the result of the 
 parsing and elaboration). Its main contents is the list of global 
 declarations and definitions. You can iterate over the globals in a 
 <a href="Cil.html#TYPEfile"><code class="code">Cil.file</code></a> using the following iterators: <a href="Cil.html#VALmapGlobals"><code class="code">Cil.mapGlobals</code></a>, 
 <a href="Cil.html#VALiterGlobals"><code class="code">Cil.iterGlobals</code></a> and <a href="Cil.html#VALfoldGlobals"><code class="code">Cil.foldGlobals</code></a>. You can also use the 
 <a href="Cil.html#VALdummyFile"><code class="code">Cil.dummyFile</code></a> when you need a <a href="Cil.html#TYPEfile"><code class="code">Cil.file</code></a> as a placeholder. For each 
 global item CIL stores the source location where it appears (using the 
 type <a href="Cil.html#TYPElocation"><code class="code">Cil.location</code></a>)<br>
<br><code><span class="keyword">type</span> <a name="TYPEfile"></a><code class="type"></code>file = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>fileName&nbsp;: <code class="type">string</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The complete file name</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>globals&nbsp;: <code class="type"><a href="Cil.html#TYPEglobal">global</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>List of globals as they will appear 
                                        in the printed file</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>globinit&nbsp;: <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>An optional global initializer function. This is a function where 
 you can put stuff that must be executed before the program is 
 started. This function, is conceptually at the end of the file, 
 although it is not part of the globals list. Use <a href="Cil.html#VALgetGlobInit"><code class="code">Cil.getGlobInit</code></a> 
 to create/get one.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>globinitcalled&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Whether the global initialization function is called in main. This 
 should always be false if there is no global initializer. When you 
 create a global initialization CIL will try to insert code in main 
 to call it. This will not happen if your file does not contain a 
 function called "main"</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info">
Top-level representation of a C source file<br>
</div>

<pre><span class="keyword">type</span> <a name="TYPEcomment"></a><code class="type"></code>comment = <code class="type"><a href="Cil.html#TYPElocation">location</a> * string</code> </pre>

<br>
<b>Globals</b>. The main type for representing global declarations and 
 definitions. A list of these form a CIL file. The order of globals in the 
 file is generally important.<br>
<br><code><span class="keyword">type</span> <a name="TYPEglobal"></a><code class="type"></code>global = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">GType</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtypeinfo">typeinfo</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A typedef. All uses of type names (through the <code class="code">TNamed</code> constructor) 
        must be preceded in the file by a definition of the name. The string 
        is the defined name and always not-empty.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">GCompTag</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEcompinfo">compinfo</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Defines a struct/union tag with some fields. There must be one of 
        these for each struct/union tag that you use (through the <code class="code">TComp</code> 
        constructor) since this is the only context in which the fields are 
        printed. Consequently nested structure tag definitions must be 
        broken into individual definitions with the innermost structure 
        defined first.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">GCompTagDecl</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEcompinfo">compinfo</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Declares a struct/union tag. Use as a forward declaration. This is 
 printed without the fields.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">GEnumTag</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEenuminfo">enuminfo</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Declares an enumeration tag with some fields. There must be one of 
      these for each enumeration tag that you use (through the <code class="code">TEnum</code> 
      constructor) since this is the only context in which the items are 
      printed.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">GEnumTagDecl</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEenuminfo">enuminfo</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Declares an enumeration tag. Use as a forward declaration. This is 
 printed without the items.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">GVarDecl</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A variable declaration (not a definition). If the variable has a 
       function type then this is a prototype. There can be several 
       declarations and at most one definition for a given variable. If both 
       forms appear then they must share the same varinfo structure. A 
       prototype shares the varinfo with the fundec of the definition. Either 
       has storage Extern or there must be a definition in this file</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">GVar</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo</a> * <a href="Cil.html#TYPEinitinfo">initinfo</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A variable definition. Can have an initializer. The initializer is 
 updateable so that you can change it without requiring to recreate 
 the list of globals. There can be at most one definition for a 
 variable in an entire program. Cannot have storage Extern or function 
 type.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">GFun</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A function definition.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">GAsm</span> <span class="keyword">of</span> <code class="type">string * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Global asm statement. These ones 
                                            can contain only a template</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">GPragma</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattribute">attribute</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Pragmas at top level. Use the same 
                                            syntax as attributes</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">GText</span> <span class="keyword">of</span> <code class="type">string</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Some text (printed verbatim) at 
                                            top level. E.g., this way you can 
                                            put comments in the output.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
A global declaration or definition<br>
</div>

<br>
<b>Types</b>. A C type is represented in CIL using the type <a href="Cil.html#TYPEtyp"><code class="code">Cil.typ</code></a>. 
 Among types we differentiate the integral types (with different kinds 
 denoting the sign and precision), floating point types, enumeration types, 
 array and pointer types, and function types. Every type is associated with 
 a list of attributes, which are always kept in sorted order. Use 
 <a href="Cil.html#VALaddAttribute"><code class="code">Cil.addAttribute</code></a> and <a href="Cil.html#VALaddAttributes"><code class="code">Cil.addAttributes</code></a> to construct list of 
 attributes. If you want to inspect a type, you should use 
 <a href="Cil.html#VALunrollType"><code class="code">Cil.unrollType</code></a> or <a href="Cil.html#VALunrollTypeDeep"><code class="code">Cil.unrollTypeDeep</code></a> to see through the uses of 
 named types.<br>
<br>
CIL is configured at build-time with the sizes and alignments of the 
 underlying compiler (GCC or MSVC). CIL contains functions that can compute 
 the size of a type (in bits) <a href="Cil.html#VALbitsSizeOf"><code class="code">Cil.bitsSizeOf</code></a>, the alignment of a type 
 (in bytes) <a href="Cil.html#VALalignOf_int"><code class="code">Cil.alignOf_int</code></a>, and can convert an offset into a start and 
 width (both in bits) using the function <a href="Cil.html#VALbitsOffset"><code class="code">Cil.bitsOffset</code></a>. At the moment 
 these functions do not take into account the <code class="code">packed</code> attributes and 
 pragmas.<br>
<br><code><span class="keyword">type</span> <a name="TYPEtyp"></a><code class="type"></code>typ = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">TVoid</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattributes">attributes</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Void type. Also predefined as <a href="Cil.html#VALvoidType"><code class="code">Cil.voidType</code></a></code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">TInt</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEikind">ikind</a> * <a href="Cil.html#TYPEattributes">attributes</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>An integer type. The kind specifies the sign and width. Several 
 useful variants are predefined as <a href="Cil.html#VALintType"><code class="code">Cil.intType</code></a>, <a href="Cil.html#VALuintType"><code class="code">Cil.uintType</code></a>, 
 <a href="Cil.html#VALlongType"><code class="code">Cil.longType</code></a>, <a href="Cil.html#VALcharType"><code class="code">Cil.charType</code></a>.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">TFloat</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEfkind">fkind</a> * <a href="Cil.html#TYPEattributes">attributes</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A floating-point type. The kind specifies the precision. You can 
 also use the predefined constant <a href="Cil.html#VALdoubleType"><code class="code">Cil.doubleType</code></a>.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">TPtr</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEattributes">attributes</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Pointer type. Several useful variants are predefined as 
 <a href="Cil.html#VALcharPtrType"><code class="code">Cil.charPtrType</code></a>, <a href="Cil.html#VALcharConstPtrType"><code class="code">Cil.charConstPtrType</code></a> (pointer to a 
 constant character), <a href="Cil.html#VALvoidPtrType"><code class="code">Cil.voidPtrType</code></a>, 
 <a href="Cil.html#VALintPtrType"><code class="code">Cil.intPtrType</code></a></code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">TArray</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEexp">exp</a> option * <a href="Cil.html#TYPEattributes">attributes</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Array type. It indicates the base type and the array length.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">TFun</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a> * (string * <a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEattributes">attributes</a>) list option * bool<br>        * <a href="Cil.html#TYPEattributes">attributes</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Function type. Indicates the type of the result, the name, type 
 and name attributes of the formal arguments (<code class="code">None</code> if no 
 arguments were specified, as in a function whose definition or 
 prototype we have not seen; <code class="code">Some []</code> means void). Use 
 <a href="Cil.html#VALargsToList"><code class="code">Cil.argsToList</code></a> to obtain a list of arguments. The boolean 
 indicates if it is a variable-argument function. If this is the 
 type of a varinfo for which we have a function declaration then 
 the information for the formals must match that in the 
 function's sformals. Use <a href="Cil.html#VALsetFormals"><code class="code">Cil.setFormals</code></a>, or 
 <a href="Cil.html#VALsetFunctionType"><code class="code">Cil.setFunctionType</code></a>, or <a href="Cil.html#VALmakeFormalVar"><code class="code">Cil.makeFormalVar</code></a> for this 
 purpose.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">TNamed</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtypeinfo">typeinfo</a> * <a href="Cil.html#TYPEattributes">attributes</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">TComp</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEcompinfo">compinfo</a> * <a href="Cil.html#TYPEattributes">attributes</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The most delicate issue for C types is that recursion that is possible by 
 using structures and pointers. To address this issue we have a more 
 complex representation for structured types (struct and union). Each such 
 type is represented using the <a href="Cil.html#TYPEcompinfo"><code class="code">Cil.compinfo</code></a> type. For each composite 
 type the <a href="Cil.html#TYPEcompinfo"><code class="code">Cil.compinfo</code></a> structure must be declared at top level using 
 <code class="code">GCompTag</code> and all references to it must share the same copy of the 
 structure. The attributes given are those pertaining to this use of the 
 type and are in addition to the attributes that were given at the 
 definition of the type and which are stored in the <a href="Cil.html#TYPEcompinfo"><code class="code">Cil.compinfo</code></a>.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">TEnum</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEenuminfo">enuminfo</a> * <a href="Cil.html#TYPEattributes">attributes</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A reference to an enumeration type. All such references must
               share the enuminfo among them and with a <code class="code">GEnumTag</code> global that 
               precedes all uses. The attributes refer to this use of the 
               enumeration and are in addition to the attributes of the 
               enumeration itself, which are stored inside the enuminfo</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">TBuiltin_va_list</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattributes">attributes</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>This is the same as the gcc's type with the same name</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>


<br>
There are a number of functions for querying the kind of a type. These are
 <a href="Cil.html#VALisIntegralType"><code class="code">Cil.isIntegralType</code></a>, 
 <a href="Cil.html#VALisArithmeticType"><code class="code">Cil.isArithmeticType</code></a>, 
 <a href="Cil.html#VALisPointerType"><code class="code">Cil.isPointerType</code></a>, 
 <a href="Cil.html#VALisFunctionType"><code class="code">Cil.isFunctionType</code></a>, 
 <a href="Cil.html#VALisArrayType"><code class="code">Cil.isArrayType</code></a>. 
<p>

 There are two easy ways to scan a type. First, you can use the
<a href="Cil.html#VALexistsType"><code class="code">Cil.existsType</code></a> to return a boolean answer about a type. This function
is controlled by a user-provided function that is queried for each type that is
used to construct the current type. The function can specify whether to
terminate the scan with a boolean result or to continue the scan for the
nested types. 
<p>

 The other method for scanning types is provided by the visitor interface (see
 <a href="Cil.cilVisitor.html"><code class="code">Cil.cilVisitor</code></a>).
<p>

 If you want to compare types (or to use them as hash-values) then you should
use instead type signatures (represented as <a href="Cil.html#TYPEtypsig"><code class="code">Cil.typsig</code></a>). These
contain the same information as types but canonicalized such that simple Ocaml
structural equality will tell whether two types are equal. Use
<a href="Cil.html#VALtypeSig"><code class="code">Cil.typeSig</code></a> to compute the signature of a type. If you want to ignore
certain type attributes then use <a href="Cil.html#VALtypeSigWithAttrs"><code class="code">Cil.typeSigWithAttrs</code></a>.<br>
<br><code><span class="keyword">type</span> <a name="TYPEikind"></a><code class="type"></code>ikind = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">IChar</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code><code class="code">char</code></code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">ISChar</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code><code class="code">signed char</code></code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">IUChar</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code><code class="code">unsigned char</code></code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">IInt</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code><code class="code">int</code></code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">IUInt</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code><code class="code">unsigned int</code></code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">IShort</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code><code class="code">short</code></code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">IUShort</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code><code class="code">unsigned short</code></code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">ILong</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code><code class="code">long</code></code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">IULong</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code><code class="code">unsigned long</code></code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">ILongLong</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code><code class="code">long long</code> (or <code class="code">_int64</code> on Microsoft Visual C)</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">IULongLong</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code><code class="code">unsigned long long</code> (or <code class="code">unsigned _int64</code> on Microsoft 
                    Visual C)</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
Various kinds of integers<br>
</div>

<br><code><span class="keyword">type</span> <a name="TYPEfkind"></a><code class="type"></code>fkind = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">FFloat</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code><code class="code">float</code></code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">FDouble</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code><code class="code">double</code></code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">FLongDouble</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code><code class="code">long double</code></code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
Various kinds of floating-point numbers<br>
</div>

<br>
<b>Attributes.</b><br>
<br><code><span class="keyword">type</span> <a name="TYPEattribute"></a><code class="type"></code>attribute = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Attr</span> <span class="keyword">of</span> <code class="type">string * <a href="Cil.html#TYPEattrparam">attrparam</a> list</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>An attribute has a name and some optional parameters. The name should not 
 start or end with underscore. When CIL parses attribute names it will 
 strip leading and ending underscores (to ensure that the multitude of GCC 
 attributes such as const, __const and __const__ all mean the same thing.)</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>


<pre><span class="keyword">type</span> <a name="TYPEattributes"></a><code class="type"></code>attributes = <code class="type"><a href="Cil.html#TYPEattribute">attribute</a> list</code> </pre>
<div class="info">
Attributes are lists sorted by the attribute name. Use the functions 
 <a href="Cil.html#VALaddAttribute"><code class="code">Cil.addAttribute</code></a> and <a href="Cil.html#VALaddAttributes"><code class="code">Cil.addAttributes</code></a> to insert attributes in an 
 attribute list and maintain the sortedness.<br>
</div>

<br><code><span class="keyword">type</span> <a name="TYPEattrparam"></a><code class="type"></code>attrparam = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">AInt</span> <span class="keyword">of</span> <code class="type">int</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>An integer constant</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">AStr</span> <span class="keyword">of</span> <code class="type">string</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A string constant</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">ACons</span> <span class="keyword">of</span> <code class="type">string * <a href="Cil.html#TYPEattrparam">attrparam</a> list</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Constructed attributes. These 
                                             are printed <code class="code">foo(a1,a2,...,an)</code>. 
                                             The list of parameters can be 
                                             empty and in that case the 
                                             parentheses are not printed.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">ASizeOf</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A way to talk about types</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">ASizeOfE</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattrparam">attrparam</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">ASizeOfS</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtypsig">typsig</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Replacement for ASizeOf in type
                                             signatures.  Only used for
                                             attributes inside typsigs.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">AAlignOf</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">AAlignOfE</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattrparam">attrparam</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">AAlignOfS</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtypsig">typsig</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">AUnOp</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEunop">unop</a> * <a href="Cil.html#TYPEattrparam">attrparam</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">ABinOp</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEbinop">binop</a> * <a href="Cil.html#TYPEattrparam">attrparam</a> * <a href="Cil.html#TYPEattrparam">attrparam</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">ADot</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattrparam">attrparam</a> * string</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>a.foo *</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
The type of parameters of attributes<br>
</div>

<br>
<b>Structures.</b> The <a href="Cil.html#TYPEcompinfo"><code class="code">Cil.compinfo</code></a> describes the definition of a 
 structure or union type. Each such <a href="Cil.html#TYPEcompinfo"><code class="code">Cil.compinfo</code></a> must be defined at the 
 top-level using the <code class="code">GCompTag</code> constructor and must be shared by all 
 references to this type (using either the <code class="code">TComp</code> type constructor or from 
 the definition of the fields. 
<p>

   If all you need is to scan the definition of each 
 composite type once, you can do that by scanning all top-level <code class="code">GCompTag</code>. 
<p>

 Constructing a <a href="Cil.html#TYPEcompinfo"><code class="code">Cil.compinfo</code></a> can be tricky since it must contain fields 
 that might refer to the host <a href="Cil.html#TYPEcompinfo"><code class="code">Cil.compinfo</code></a> and furthermore the type of 
 the field might need to refer to the <a href="Cil.html#TYPEcompinfo"><code class="code">Cil.compinfo</code></a> for recursive types. 
 Use the <a href="Cil.html#VALmkCompInfo"><code class="code">Cil.mkCompInfo</code></a> function to create a <a href="Cil.html#TYPEcompinfo"><code class="code">Cil.compinfo</code></a>. You can 
 easily fetch the <a href="Cil.html#TYPEfieldinfo"><code class="code">Cil.fieldinfo</code></a> for a given field in a structure with 
 <a href="Cil.html#VALgetCompField"><code class="code">Cil.getCompField</code></a>.<br>
<br><code><span class="keyword">type</span> <a name="TYPEcompinfo"></a><code class="type"></code>compinfo = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>cstruct&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>True if struct, False if union</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>cname&nbsp;: <code class="type">string</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The name. Always non-empty. Use <a href="Cil.html#VALcompFullName"><code class="code">Cil.compFullName</code></a> to get the full 
 name of a comp (along with the struct or union)</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>ckey&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A unique integer. This is assigned by <a href="Cil.html#VALmkCompInfo"><code class="code">Cil.mkCompInfo</code></a> using a 
 global variable in the Cil module. Thus two identical structs in two 
 different files might have different keys. Use <a href="Cil.html#VALcopyCompInfo"><code class="code">Cil.copyCompInfo</code></a> to 
 copy structures so that a new key is assigned.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>cfields&nbsp;: <code class="type"><a href="Cil.html#TYPEfieldinfo">fieldinfo</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Information about the fields. Notice that each fieldinfo has a 
 pointer back to the host compinfo. This means that you should not 
 share fieldinfo's between two compinfo's</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>cattr&nbsp;: <code class="type"><a href="Cil.html#TYPEattributes">attributes</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The attributes that are defined at the same time as the composite 
 type. These attributes can be supplemented individually at each 
 reference to this <code class="code">compinfo</code> using the <code class="code">TComp</code> type constructor.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>cdefined&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>This boolean flag can be used to distinguish between structures
     that have not been defined and those that have been defined but have
     no fields (such things are allowed in gcc).</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>creferenced&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>True if used. Initially set to false.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info">
The definition of a structure or union type. Use <a href="Cil.html#VALmkCompInfo"><code class="code">Cil.mkCompInfo</code></a> to 
 make one and use <a href="Cil.html#VALcopyCompInfo"><code class="code">Cil.copyCompInfo</code></a> to copy one (this ensures that a new 
 key is assigned and that the fields have the right pointers to parents.).<br>
</div>

<br>
<b>Structure fields.</b> The <a href="Cil.html#TYPEfieldinfo"><code class="code">Cil.fieldinfo</code></a> structure is used to describe 
 a structure or union field. Fields, just like variables, can have 
 attributes associated with the field itself or associated with the type of 
 the field (stored along with the type of the field).<br>
<br><code><span class="keyword">type</span> <a name="TYPEfieldinfo"></a><code class="type"></code>fieldinfo = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>fcomp&nbsp;: <code class="type"><a href="Cil.html#TYPEcompinfo">compinfo</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The host structure that contains this field. There can be only one 
 <code class="code">compinfo</code> that contains the field.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>fname&nbsp;: <code class="type">string</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The name of the field. Might be the value of <a href="Cil.html#VALmissingFieldName"><code class="code">Cil.missingFieldName</code></a> 
 in which case it must be a bitfield and is not printed and it does not 
 participate in initialization</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>ftype&nbsp;: <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The type</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>fbitfield&nbsp;: <code class="type">int option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>If a bitfield then ftype should be an integer type and the width of 
 the bitfield must be 0 or a positive integer smaller or equal to the 
 width of the integer type. A field of width 0 is used in C to control 
 the alignment of fields.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>fattr&nbsp;: <code class="type"><a href="Cil.html#TYPEattributes">attributes</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The attributes for this field (not for its type)</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>floc&nbsp;: <code class="type"><a href="Cil.html#TYPElocation">location</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The location where this field is defined</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info">
Information about a struct/union field<br>
</div>

<br>
<b>Enumerations.</b> Information about an enumeration. This is shared by all 
 references to an enumeration. Make sure you have a <code class="code">GEnumTag</code> for each of 
 of these.<br>
<br><code><span class="keyword">type</span> <a name="TYPEenuminfo"></a><code class="type"></code>enuminfo = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>ename&nbsp;: <code class="type">string</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The name. Always non-empty.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>eitems&nbsp;: <code class="type">(string * <a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPElocation">location</a>) list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Items with names and values. This list should be non-empty. The item 
 values must be compile-time constants.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>eattr&nbsp;: <code class="type"><a href="Cil.html#TYPEattributes">attributes</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The attributes that are defined at the same time as the enumeration 
 type. These attributes can be supplemented individually at each 
 reference to this <code class="code">enuminfo</code> using the <code class="code">TEnum</code> type constructor.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>ereferenced&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>True if used. Initially set to false</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info">
Information about an enumeration<br>
</div>

<br>
<b>Enumerations.</b> Information about an enumeration. This is shared by all 
 references to an enumeration. Make sure you have a <code class="code">GEnumTag</code> for each of 
 of these.<br>
<br><code><span class="keyword">type</span> <a name="TYPEtypeinfo"></a><code class="type"></code>typeinfo = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>tname&nbsp;: <code class="type">string</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The name. Can be empty only in a <code class="code">GType</code> when introducing a composite 
 or enumeration tag. If empty cannot be referred to from the file</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>ttype&nbsp;: <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The actual type. This includes the attributes that were present in 
 the typedef</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>treferenced&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>True if used. Initially set to false</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info">
Information about a defined type<br>
</div>

<br>
<b>Variables.</b> 
 Each local or global variable is represented by a unique <a href="Cil.html#TYPEvarinfo"><code class="code">Cil.varinfo</code></a>
structure. A global <a href="Cil.html#TYPEvarinfo"><code class="code">Cil.varinfo</code></a> can be introduced with the <code class="code">GVarDecl</code> or
<code class="code">GVar</code> or <code class="code">GFun</code> globals. A local varinfo can be introduced as part of a
function definition <a href="Cil.html#TYPEfundec"><code class="code">Cil.fundec</code></a>. 
<p>

 All references to a given global or local variable must refer to the same
copy of the <code class="code">varinfo</code>. Each <code class="code">varinfo</code> has a globally unique identifier that 
can be used to index maps and hashtables (the name can also be used for this 
purpose, except for locals from different functions). This identifier is 
constructor using a global counter.
<p>

 It is very important that you construct <code class="code">varinfo</code> structures using only one
 of the following functions:<ul>
<li><a href="Cil.html#VALmakeGlobalVar"><code class="code">Cil.makeGlobalVar</code></a> : to make a global variable</li>
<li><a href="Cil.html#VALmakeTempVar"><code class="code">Cil.makeTempVar</code></a> : to make a temporary local variable whose name
will be generated so that to avoid conflict with other locals. </li>
<li><a href="Cil.html#VALmakeLocalVar"><code class="code">Cil.makeLocalVar</code></a> : like <a href="Cil.html#VALmakeTempVar"><code class="code">Cil.makeTempVar</code></a> but you can specify the
exact name to be used. </li>
<li><a href="Cil.html#VALcopyVarinfo"><code class="code">Cil.copyVarinfo</code></a>: make a shallow copy of a varinfo assigning a new name 
and a new unique identifier</li>
</ul>

 A <code class="code">varinfo</code> is also used in a function type to denote the list of formals.<br>
<br><code><span class="keyword">type</span> <a name="TYPEvarinfo"></a><code class="type"></code>varinfo = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>vname&nbsp;: <code class="type">string</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The name of the variable. Cannot be empty. It is primarily your 
 responsibility to ensure the uniqueness of a variable name. For local 
 variables <a href="Cil.html#VALmakeTempVar"><code class="code">Cil.makeTempVar</code></a> helps you ensure that the name is unique.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>vtype&nbsp;: <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The declared type of the variable.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>vattr&nbsp;: <code class="type"><a href="Cil.html#TYPEattributes">attributes</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A list of attributes associated with the variable.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>vstorage&nbsp;: <code class="type"><a href="Cil.html#TYPEstorage">storage</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The storage-class</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>vglob&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>True if this is a global variable</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>vinline&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Whether this varinfo is for an inline function.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>vdecl&nbsp;: <code class="type"><a href="Cil.html#TYPElocation">location</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Location of variable declaration.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>vid&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A unique integer identifier. This field will be 
 set for you if you use one of the <a href="Cil.html#VALmakeFormalVar"><code class="code">Cil.makeFormalVar</code></a>, 
 <a href="Cil.html#VALmakeLocalVar"><code class="code">Cil.makeLocalVar</code></a>, <a href="Cil.html#VALmakeTempVar"><code class="code">Cil.makeTempVar</code></a>, <a href="Cil.html#VALmakeGlobalVar"><code class="code">Cil.makeGlobalVar</code></a>, or 
 <a href="Cil.html#VALcopyVarinfo"><code class="code">Cil.copyVarinfo</code></a>.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>vaddrof&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>True if the address of this variable is taken. CIL will set these 
 flags when it parses C, but you should make sure to set the flag 
 whenever your transformation create <code class="code">AddrOf</code> expression.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>vreferenced&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>True if this variable is ever referenced. This is computed by 
 <code class="code">removeUnusedVars</code>. It is safe to just initialize this to False</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info">
Information about a variable.<br>
</div>

<br><code><span class="keyword">type</span> <a name="TYPEstorage"></a><code class="type"></code>storage = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">NoStorage</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The default storage. Nothing is printed</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Static</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Register</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Extern</span></code></td>

</tr></table>

<div class="info">
Storage-class information<br>
</div>

<br>
<b>Expressions.</b> The CIL expression language contains only the side-effect free expressions of
C. They are represented as the type <a href="Cil.html#TYPEexp"><code class="code">Cil.exp</code></a>. There are several
interesting aspects of CIL expressions: 
<p>

 Integer and floating point constants can carry their textual representation.
This way the integer 15 can be printed as 0xF if that is how it occurred in the
source. 
<p>

 CIL uses 64 bits to represent the integer constants and also stores the width
of the integer type. Care must be taken to ensure that the constant is
representable with the given width. Use the functions <a href="Cil.html#VALkinteger"><code class="code">Cil.kinteger</code></a>,
<a href="Cil.html#VALkinteger64"><code class="code">Cil.kinteger64</code></a> and <a href="Cil.html#VALinteger"><code class="code">Cil.integer</code></a> to construct constant
expressions. CIL predefines the constants <a href="Cil.html#VALzero"><code class="code">Cil.zero</code></a>,
<a href="Cil.html#VALone"><code class="code">Cil.one</code></a> and <a href="Cil.html#VALmone"><code class="code">Cil.mone</code></a> (for -1). 
<p>

 Use the functions <a href="Cil.html#VALisConstant"><code class="code">Cil.isConstant</code></a> and <a href="Cil.html#VALisInteger"><code class="code">Cil.isInteger</code></a> to test if
an expression is a constant and a constant integer respectively.
<p>

 CIL keeps the type of all unary and binary expressions. You can think of that
type qualifying the operator. Furthermore there are different operators for
arithmetic and comparisons on arithmetic types and on pointers. 
<p>

 Another unusual aspect of CIL is that the implicit conversion between an
expression of array type and one of pointer type is made explicit, using the
<code class="code">StartOf</code> expression constructor (which is not printed). If you apply the
<code class="code">AddrOf}</code>constructor to an lvalue of type <code class="code">T</code> then you will be getting an
expression of type <code class="code">TPtr(T)</code>.
<p>

 You can find the type of an expression with <a href="Cil.html#VALtypeOf"><code class="code">Cil.typeOf</code></a>. 
<p>

 You can perform constant folding on expressions using the function
<a href="Cil.html#VALconstFold"><code class="code">Cil.constFold</code></a>.<br>
<br><code><span class="keyword">type</span> <a name="TYPEexp"></a><code class="type"></code>exp = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Const</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEconstant">constant</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Constant</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Lval</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPElval">lval</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Lvalue</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SizeOf</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>sizeof(&lt;type&gt;). Has <code class="code">unsigned int</code> type (ISO 6.5.3.4). This is not 
 turned into a constant because some transformations might want to 
 change types</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SizeOfE</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>sizeof(&lt;expression&gt;)</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SizeOfStr</span> <span class="keyword">of</span> <code class="type">string</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>sizeof(string_literal). We separate this case out because this is the 
 only instance in which a string literal should not be treated as 
 having type pointer to character.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">AlignOf</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>This corresponds to the GCC __alignof_. Has <code class="code">unsigned int</code> type</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">AlignOfE</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">UnOp</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEunop">unop</a> * <a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPEtyp">typ</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Unary operation. Includes the type of the result.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">BinOp</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEbinop">binop</a> * <a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPEtyp">typ</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Binary operation. Includes the type of the result. The arithmetic 
 conversions are made explicit for the arguments.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">CastE</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEexp">exp</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Use <a href="Cil.html#VALmkCast"><code class="code">Cil.mkCast</code></a> to make casts.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">AddrOf</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPElval">lval</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Always use <a href="Cil.html#VALmkAddrOf"><code class="code">Cil.mkAddrOf</code></a> to construct one of these. Apply to an 
 lvalue of type <code class="code">T</code> yields an expression of type <code class="code">TPtr(T)</code></code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">StartOf</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPElval">lval</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Conversion from an array to a pointer to the beginning of the array. 
 Given an lval of type <code class="code">TArray(T)</code> produces an expression of type 
 <code class="code">TPtr(T)</code>. In C this operation is implicit, the <code class="code">StartOf</code> operator is 
 not printed. We have it in CIL because it makes the typing rules 
 simpler.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
Expressions (Side-effect free)<br>
</div>

<br>
<b>Constants.</b><br>
<br><code><span class="keyword">type</span> <a name="TYPEconstant"></a><code class="type"></code>constant = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">CInt64</span> <span class="keyword">of</span> <code class="type">int64 * <a href="Cil.html#TYPEikind">ikind</a> * string option</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Integer constant. Give the ikind (see ISO9899 6.1.3.2) and the 
 textual representation, if available. (This allows us to print a 
 constant as, for example, 0xF instead of 15.) Use <a href="Cil.html#VALinteger"><code class="code">Cil.integer</code></a> or 
 <a href="Cil.html#VALkinteger"><code class="code">Cil.kinteger</code></a> to create these. Watch out for integers that cannot be 
 represented on 64 bits. OCAML does not give Overflow exceptions.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">CStr</span> <span class="keyword">of</span> <code class="type">string</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">CWStr</span> <span class="keyword">of</span> <code class="type">int64 list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">CChr</span> <span class="keyword">of</span> <code class="type">char</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Character constant.  This has type int, so use charConstToInt
 to read the value in case sign-extension is needed.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">CReal</span> <span class="keyword">of</span> <code class="type">float * <a href="Cil.html#TYPEfkind">fkind</a> * string option</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Floating point constant. Give the fkind (see ISO 6.4.4.2) and also 
 the textual representation, if available.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">CEnum</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a> * string * <a href="Cil.html#TYPEenuminfo">enuminfo</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>An enumeration constant with the given value, name, from the given 
 enuminfo. This is used only if <a href="Cil.html#VALlowerConstants"><code class="code">Cil.lowerConstants</code></a> is true 
 (default). Use <a href="Cil.html#VALconstFoldVisitor"><code class="code">Cil.constFoldVisitor</code></a> to replace these with integer 
 constants.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
Literal constants<br>
</div>

<br><code><span class="keyword">type</span> <a name="TYPEunop"></a><code class="type"></code>unop = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Neg</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Unary minus</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">BNot</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Bitwise complement (~)</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">LNot</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Logical Not (!)</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
Unary operators<br>
</div>

<br><code><span class="keyword">type</span> <a name="TYPEbinop"></a><code class="type"></code>binop = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">PlusA</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>arithmetic +</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">PlusPI</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>pointer + integer</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">IndexPI</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>pointer + integer but only when 
 it arises from an expression 
 <code class="code">e[i]</code> when <code class="code">e</code> is a pointer and 
 not an array. This is semantically 
 the same as PlusPI but CCured uses 
 this as a hint that the integer is 
 probably positive.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">MinusA</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>arithmetic -</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">MinusPI</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>pointer - integer</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">MinusPP</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>pointer - pointer</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Mult</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Div</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>/</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Mod</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>%</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Shiftlt</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>shift left</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Shiftrt</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>shift right</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Lt</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>&lt;  (arithmetic comparison)</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Gt</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>&gt;  (arithmetic comparison)</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Le</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>&lt;= (arithmetic comparison)</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Ge</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>&gt;  (arithmetic comparison)</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Eq</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>== (arithmetic comparison)</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Ne</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>!= (arithmetic comparison)</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">BAnd</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>bitwise and</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">BXor</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>exclusive-or</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">BOr</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>inclusive-or</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">LAnd</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>logical and. Unlike other 
 expressions this one does not 
 always evaluate both operands. If 
 you want to use these, you must 
 set <a href="Cil.html#VALuseLogicalOperators"><code class="code">Cil.useLogicalOperators</code></a>.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">LOr</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>logical or. Unlike other 
 expressions this one does not 
 always evaluate both operands.  If 
 you want to use these, you must 
 set <a href="Cil.html#VALuseLogicalOperators"><code class="code">Cil.useLogicalOperators</code></a>.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
Binary operations<br>
</div>

<br>
<b>Lvalues.</b> Lvalues are the sublanguage of expressions that can appear at the left of an assignment or as operand to the address-of operator. 
In C the syntax for lvalues is not always a good indication of the meaning 
of the lvalue. For example the C value
<pre> 
a[0][1][2]
</pre>
 might involve 1, 2 or 3 memory reads when used in an expression context,
depending on the declared type of the variable <code class="code">a</code>. If <code class="code">a</code> has type <code class="code">int
[4][4][4]</code> then we have one memory read from somewhere inside the area 
that stores the array <code class="code">a</code>. On the other hand if <code class="code">a</code> has type <code class="code">int ***</code> then
the expression really means <code class="code">* ( * ( * (a + 0) + 1) + 2)</code>, in which case it is
clear that it involves three separate memory operations. 
<p>

An lvalue denotes the contents of a range of memory addresses. This range 
is denoted as a host object along with an offset within the object. The 
host object can be of two kinds: a local or global variable, or an object 
whose address is in a pointer expression. We distinguish the two cases so 
that we can tell quickly whether we are accessing some component of a 
variable directly or we are accessing a memory location through a pointer.
To make it easy to 
tell what an lvalue means CIL represents lvalues as a host object and an
offset (see <a href="Cil.html#TYPElval"><code class="code">Cil.lval</code></a>). The host object (represented as
<a href="Cil.html#TYPElhost"><code class="code">Cil.lhost</code></a>) can be a local or global variable or can be the object
pointed-to by a pointer expression. The offset (represented as
<a href="Cil.html#TYPEoffset"><code class="code">Cil.offset</code></a>) is a sequence of field or array index designators.
<p>

 Both the typing rules and the meaning of an lvalue is very precisely
specified in CIL. 
<p>

 The following are a few useful function for operating on lvalues:<ul>
<li><a href="Cil.html#VALmkMem"><code class="code">Cil.mkMem</code></a> - makes an lvalue of <code class="code">Mem</code> kind. Use this to ensure
that certain equivalent forms of lvalues are canonized. 
For example, <code class="code">*&amp;x = x</code>. </li>
<li><a href="Cil.html#VALtypeOfLval"><code class="code">Cil.typeOfLval</code></a> - the type of an lvalue</li>
<li><a href="Cil.html#VALtypeOffset"><code class="code">Cil.typeOffset</code></a> - the type of an offset, given the type of the
host. </li>
<li><a href="Cil.html#VALaddOffset"><code class="code">Cil.addOffset</code></a> and <a href="Cil.html#VALaddOffsetLval"><code class="code">Cil.addOffsetLval</code></a> - extend sequences
of offsets.</li>
<li><a href="Cil.html#VALremoveOffset"><code class="code">Cil.removeOffset</code></a> and <a href="Cil.html#VALremoveOffsetLval"><code class="code">Cil.removeOffsetLval</code></a> - shrink sequences
of offsets.</li>
</ul>

The following equivalences hold <pre>
Mem(AddrOf(Mem a, aoff)), off   = Mem a, aoff + off 
Mem(AddrOf(Var v, aoff)), off   = Var v, aoff + off 
AddrOf (Mem a, NoOffset)        = a                 
</pre><br>
<pre><span class="keyword">type</span> <a name="TYPElval"></a><code class="type"></code>lval = <code class="type"><a href="Cil.html#TYPElhost">lhost</a> * <a href="Cil.html#TYPEoffset">offset</a></code> </pre>
<div class="info">
An lvalue<br>
</div>

<br><code><span class="keyword">type</span> <a name="TYPElhost"></a><code class="type"></code>lhost = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Var</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The host is a variable.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Mem</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The host is an object of type <code class="code">T</code> when the expression has pointer 
 <code class="code">TPtr(T)</code>.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
The host part of an <a href="Cil.html#TYPElval"><code class="code">Cil.lval</code></a>.<br>
</div>

<br><code><span class="keyword">type</span> <a name="TYPEoffset"></a><code class="type"></code>offset = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">NoOffset</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>No offset. Can be applied to any lvalue and does 
 not change either the starting address or the type. 
 This is used when the lval consists of just a host 
 or as a terminator in a list of other kinds of 
 offsets.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Field</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEfieldinfo">fieldinfo</a> * <a href="Cil.html#TYPEoffset">offset</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A field offset. Can be applied only to an lvalue 
 that denotes a structure or a union that contains 
 the mentioned field. This advances the offset to the 
 beginning of the mentioned field and changes the 
 type to the type of the mentioned field.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Index</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPEoffset">offset</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>An array index offset. Can be applied only to an 
 lvalue that denotes an array. This advances the 
 starting address of the lval to the beginning of the 
 mentioned array element and changes the denoted type 
 to be the type of the array element</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
The offset part of an <a href="Cil.html#TYPElval"><code class="code">Cil.lval</code></a>. Each offset can be applied to certain 
 kinds of lvalues and its effect is that it advances the starting address 
 of the lvalue and changes the denoted type, essentially focusing to some 
 smaller lvalue that is contained in the original one.<br>
</div>

<br>
<b>Initializers.</b> 
A special kind of expressions are those that can appear as initializers for
global variables (initialization of local variables is turned into
assignments). The initializers are represented as type <a href="Cil.html#TYPEinit"><code class="code">Cil.init</code></a>. You
can create initializers with <a href="Cil.html#VALmakeZeroInit"><code class="code">Cil.makeZeroInit</code></a> and you can conveniently
scan compound initializers them with <a href="Cil.html#VALfoldLeftCompound"><code class="code">Cil.foldLeftCompound</code></a> or with <a href="Cil.html#VALfoldLeftCompoundAll"><code class="code">Cil.foldLeftCompoundAll</code></a>.<br>
<br><code><span class="keyword">type</span> <a name="TYPEinit"></a><code class="type"></code>init = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SingleInit</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A single initializer</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">CompoundInit</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a> * (<a href="Cil.html#TYPEoffset">offset</a> * <a href="Cil.html#TYPEinit">init</a>) list</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Used only for initializers of structures, unions and arrays. The 
 offsets are all of the form <code class="code">Field(f, NoOffset)</code> or <code class="code">Index(i, 
 NoOffset)</code> and specify the field or the index being initialized. For 
 structures all fields must have an initializer (except the unnamed 
 bitfields), in the proper order. This is necessary since the offsets 
 are not printed. For unions there must be exactly one initializer. If 
 the initializer is not for the first field then a field designator is 
 printed, so you better be on GCC since MSVC does not understand this. 
 For arrays, however, we allow you to give only a prefix of the 
 initializers. You can scan an initializer list with 
 <a href="Cil.html#VALfoldLeftCompound"><code class="code">Cil.foldLeftCompound</code></a> or with <a href="Cil.html#VALfoldLeftCompoundAll"><code class="code">Cil.foldLeftCompoundAll</code></a>.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
Initializers for global variables.<br>
</div>

<br><code><span class="keyword">type</span> <a name="TYPEinitinfo"></a><code class="type"></code>initinfo = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>init&nbsp;: <code class="type"><a href="Cil.html#TYPEinit">init</a> option</code>;</code></td>

</tr></table>
}

<div class="info">
We want to be able to update an initializer in a global variable, so we 
 define it as a mutable field<br>
</div>

<br>
<b>Function definitions.</b> 
A function definition is always introduced with a <code class="code">GFun</code> constructor at the
top level. All the information about the function is stored into a
<a href="Cil.html#TYPEfundec"><code class="code">Cil.fundec</code></a>. Some of the information (e.g. its name, type,
storage, attributes) is stored as a <a href="Cil.html#TYPEvarinfo"><code class="code">Cil.varinfo</code></a> that is a field of the
<code class="code">fundec</code>. To refer to the function from the expression language you must use
the <code class="code">varinfo</code>. 
<p>

 The function definition contains, in addition to the body, a list of all the
local variables and separately a list of the formals. Both kind of variables
can be referred to in the body of the function. The formals must also be shared
with the formals that appear in the function type. For that reason, to
manipulate formals you should use the provided functions
<a href="Cil.html#VALmakeFormalVar"><code class="code">Cil.makeFormalVar</code></a> and <a href="Cil.html#VALsetFormals"><code class="code">Cil.setFormals</code></a> and <a href="Cil.html#VALmakeFormalVar"><code class="code">Cil.makeFormalVar</code></a>.<br>
<br><code><span class="keyword">type</span> <a name="TYPEfundec"></a><code class="type"></code>fundec = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>svar&nbsp;: <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Holds the name and type as a variable, so we can refer to it 
 easily from the program. All references to this function either 
 in a function call or in a prototype must point to the same 
 <code class="code">varinfo</code>.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>sformals&nbsp;: <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Formals. These must be in the same order and with the same 
 information as the formal information in the type of the function. 
 Use <a href="Cil.html#VALsetFormals"><code class="code">Cil.setFormals</code></a> or 
 <a href="Cil.html#VALsetFunctionType"><code class="code">Cil.setFunctionType</code></a> or <a href="Cil.html#VALmakeFormalVar"><code class="code">Cil.makeFormalVar</code></a> 
 to set these formals and ensure that they 
 are reflected in the function type. Do not make copies of these 
 because the body refers to them.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>slocals&nbsp;: <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Locals. Does NOT include the sformals. Do not make copies of 
 these because the body refers to them.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>smaxid&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Max local id. Starts at 0. Used for 
 creating the names of new temporary 
 variables. Updated by 
 <a href="Cil.html#VALmakeLocalVar"><code class="code">Cil.makeLocalVar</code></a> and 
 <a href="Cil.html#VALmakeTempVar"><code class="code">Cil.makeTempVar</code></a>. You can also use 
 <a href="Cil.html#VALsetMaxId"><code class="code">Cil.setMaxId</code></a> to set it after you 
 have added the formals and locals.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>sbody&nbsp;: <code class="type"><a href="Cil.html#TYPEblock">block</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The function body.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>smaxstmtid&nbsp;: <code class="type">int option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>max id of a (reachable) statement 
 in this function, if we have 
 computed it. range = 0 ... 
 (smaxstmtid-1). This is computed by 
 <a href="Cil.html#VALcomputeCFGInfo"><code class="code">Cil.computeCFGInfo</code></a>.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>sallstmts&nbsp;: <code class="type"><a href="Cil.html#TYPEstmt">stmt</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>After you call <a href="Cil.html#VALcomputeCFGInfo"><code class="code">Cil.computeCFGInfo</code></a> 
 this field is set to contain all 
 statements in the function</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info">
Function definitions.<br>
</div>

<br><code><span class="keyword">type</span> <a name="TYPEblock"></a><code class="type"></code>block = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>battrs&nbsp;: <code class="type"><a href="Cil.html#TYPEattributes">attributes</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Attributes for the block</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>bstmts&nbsp;: <code class="type"><a href="Cil.html#TYPEstmt">stmt</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The statements comprising the block</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info">
A block is a sequence of statements with the control falling through from 
    one element to the next<br>
</div>

<br>
<b>Statements</b>. 
CIL statements are the structural elements that make the CFG. They are 
represented using the type <a href="Cil.html#TYPEstmt"><code class="code">Cil.stmt</code></a>. Every
statement has a (possibly empty) list of labels. The
<a href="Cil.html#TYPEstmtkind"><code class="code">Cil.stmtkind</code></a> field of a statement indicates what kind of statement it 
is.
<p>

 Use <a href="Cil.html#VALmkStmt"><code class="code">Cil.mkStmt</code></a> to make a statement and the fill-in the fields. 
<p>

CIL also comes with support for control-flow graphs. The <code class="code">sid</code> field in
<code class="code">stmt</code> can be used to give unique numbers to statements, and the <code class="code">succs</code>
and <code class="code">preds</code> fields can be used to maintain a list of successors and
predecessors for every statement. The CFG information is not computed by
default. Instead you must explicitly use the functions
<a href="Cil.html#VALprepareCFG"><code class="code">Cil.prepareCFG</code></a> and <a href="Cil.html#VALcomputeCFGInfo"><code class="code">Cil.computeCFGInfo</code></a> to do it.<br>
<br><code><span class="keyword">type</span> <a name="TYPEstmt"></a><code class="type"></code>stmt = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>labels&nbsp;: <code class="type"><a href="Cil.html#TYPElabel">label</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Whether the statement starts with some labels, case statements or 
 default statements.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>skind&nbsp;: <code class="type"><a href="Cil.html#TYPEstmtkind">stmtkind</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The kind of statement</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>sid&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A number (&gt;= 0) that is unique in a function. Filled in only after 
 the CFG is computed.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>succs&nbsp;: <code class="type"><a href="Cil.html#TYPEstmt">stmt</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The successor statements. They can always be computed from the skind 
 and the context in which this statement appears. Filled in only after 
 the CFG is computed.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>preds&nbsp;: <code class="type"><a href="Cil.html#TYPEstmt">stmt</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The inverse of the succs function.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info">
Statements.<br>
</div>

<br><code><span class="keyword">type</span> <a name="TYPElabel"></a><code class="type"></code>label = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Label</span> <span class="keyword">of</span> <code class="type">string * <a href="Cil.html#TYPElocation">location</a> * bool</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A real label. If the bool is "true", the label is from the 
 input source program. If the bool is "false", the label was 
 created by CIL or some other transformation</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Case</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A case statement. This expression 
 is lowered into a constant if 
 <a href="Cil.html#VALlowerConstants"><code class="code">Cil.lowerConstants</code></a> is set to 
 true.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Default</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A default statement</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
Labels<br>
</div>

<br><code><span class="keyword">type</span> <a name="TYPEstmtkind"></a><code class="type"></code>stmtkind = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Instr</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEinstr">instr</a> list</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A group of instructions that do not contain control flow. Control 
 implicitly falls through.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Return</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a> option * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The return statement. This is a leaf in the CFG.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Goto</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEstmt">stmt</a> Pervasives.ref * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A goto statement. Appears from actual goto's in the code or from 
 goto's that have been inserted during elaboration. The reference 
 points to the statement that is the target of the Goto. This means that 
 you have to update the reference whenever you replace the target 
 statement. The target statement MUST have at least a label.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Break</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A break to the end of the nearest enclosing Loop or Switch</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Continue</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A continue to the start of the nearest enclosing <code class="code">Loop</code></code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">If</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPEblock">block</a> * <a href="Cil.html#TYPEblock">block</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A conditional. Two successors, the "then" and the "else" branches. 
 Both branches fall-through to the successor of the If statement.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Switch</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPEblock">block</a> * <a href="Cil.html#TYPEstmt">stmt</a> list * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A switch statement. The statements that implement the cases can be 
 reached through the provided list. For each such target you can find 
 among its labels what cases it implements. The statements that 
 implement the cases are somewhere within the provided <code class="code">block</code>.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Loop</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEblock">block</a> * <a href="Cil.html#TYPElocation">location</a> * <a href="Cil.html#TYPEstmt">stmt</a> option * <a href="Cil.html#TYPEstmt">stmt</a> option</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A <code class="code">while(1)</code> loop. The termination test is implemented in the body of 
 a loop using a <code class="code">Break</code> statement. If prepareCFG has been called,
 the first stmt option will point to the stmt containing the continue
 label for this loop and the second will point to the stmt containing
 the break label for this loop.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Block</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEblock">block</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Just a block of statements. Use it as a way to keep some block 
 attributes local</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">TryFinally</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEblock">block</a> * <a href="Cil.html#TYPEblock">block</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">TryExcept</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEblock">block</a> * (<a href="Cil.html#TYPEinstr">instr</a> list * <a href="Cil.html#TYPEexp">exp</a>) * <a href="Cil.html#TYPEblock">block</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>

</tr></table>

<div class="info">
The various kinds of control-flow statements statements<br>
</div>

<br>
<b>Instructions</b>. 
 An instruction <a href="Cil.html#TYPEinstr"><code class="code">Cil.instr</code></a> is a statement that has no local
(intraprocedural) control flow. It can be either an assignment,
function call, or an inline assembly instruction.<br>
<br><code><span class="keyword">type</span> <a name="TYPEinstr"></a><code class="type"></code>instr = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Set</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPElval">lval</a> * <a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>An assignment. The type of the expression is guaranteed to be the same 
 with that of the lvalue</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Call</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPElval">lval</a> option * <a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPEexp">exp</a> list * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>A function call with the (optional) result placed in an lval. It is 
 possible that the returned type of the function is not identical to 
 that of the lvalue. In that case a cast is printed. The type of the 
 actual arguments are identical to those of the declared formals. The 
 number of arguments is the same as that of the declared formals, except 
 for vararg functions. This construct is also used to encode a call to 
 "__builtin_va_arg". In this case the second argument (which should be a 
 type T) is encoded SizeOf(T)</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Asm</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattributes">attributes</a> * string list * (string * <a href="Cil.html#TYPElval">lval</a>) list<br>        * (string * <a href="Cil.html#TYPEexp">exp</a>) list * string list * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>There are for storing inline assembly. They follow the GCC 
 specification: 
<pre>
  asm [volatile] ("...template..." "..template.."
                  : "c1" (o1), "c2" (o2), ..., "cN" (oN)
                  : "d1" (i1), "d2" (i2), ..., "dM" (iM)
                  : "r1", "r2", ..., "nL" );
</pre>
<p>

where the parts are
<p>
<ul>
<li><code class="code">volatile</code> (optional): when present, the assembler instruction
    cannot be removed, moved, or otherwise optimized</li>
<li>template: a sequence of strings, with %0, %1, %2, etc. in the string to 
    refer to the input and output expressions. I think they're numbered
    consecutively, but the docs don't specify. Each string is printed on 
    a separate line. This is the only part that is present for MSVC inline
    assembly.</li>
<li>"ci" (oi): pairs of constraint-string and output-lval; the 
    constraint specifies that the register used must have some
    property, like being a floating-point register; the constraint
    string for outputs also has "=" to indicate it is written, or
    "+" to indicate it is both read and written; 'oi' is the
    name of a C lvalue (probably a variable name) to be used as
    the output destination</li>
<li>"dj" (ij): pairs of constraint and input expression; the constraint
    is similar to the "ci"s.  the 'ij' is an arbitrary C expression
    to be loaded into the corresponding register</li>
<li>"rk": registers to be regarded as "clobbered" by the instruction;
    "memory" may be specified for arbitrary memory effects</li>
</ul>

an example (from gcc manual):
<pre>
  asm volatile ("movc3 %0,%1,%2"
                : /* no outputs */
                : "g" (from), "g" (to), "g" (count)
                : "r0", "r1", "r2", "r3", "r4", "r5");
</pre></code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
Instructions.<br>
</div>

<br><code><span class="keyword">type</span> <a name="TYPElocation"></a><code class="type"></code>location = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>line&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The line number. -1 means "do not know"</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>file&nbsp;: <code class="type">string</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The name of the source file</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>byte&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The byte position in the source file</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info">
Describes a location in a source file.<br>
</div>

<br><code><span class="keyword">type</span> <a name="TYPEtypsig"></a><code class="type"></code>typsig = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">TSArray</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtypsig">typsig</a> * int64 option * <a href="Cil.html#TYPEattribute">attribute</a> list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">TSPtr</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtypsig">typsig</a> * <a href="Cil.html#TYPEattribute">attribute</a> list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">TSComp</span> <span class="keyword">of</span> <code class="type">bool * string * <a href="Cil.html#TYPEattribute">attribute</a> list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">TSFun</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtypsig">typsig</a> * <a href="Cil.html#TYPEtypsig">typsig</a> list * bool * <a href="Cil.html#TYPEattribute">attribute</a> list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">TSEnum</span> <span class="keyword">of</span> <code class="type">string * <a href="Cil.html#TYPEattribute">attribute</a> list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">TSBase</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></code></td>

</tr></table>

<div class="info">
Type signatures. Two types are identical iff they have identical 
 signatures. These contain the same information as types but canonicalized. 
 For example, two function types that are identical except for the name of 
 the formal arguments are given the same signature. Also, <code class="code">TNamed</code> 
 constructors are unrolled.<br>
</div>

<br>
<b>Lowering Options</b><br>
<pre><span class="keyword">val</span> <a name="VALlowerConstants"></a>lowerConstants : <code class="type">bool Pervasives.ref</code></pre><div class="info">
Do lower constants (default true)<br>
</div>
<pre><span class="keyword">val</span> <a name="VALinsertImplicitCasts"></a>insertImplicitCasts : <code class="type">bool Pervasives.ref</code></pre><div class="info">
Do insert implicit casts (default true)<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEfeatureDescr"></a><code class="type"></code>featureDescr = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>fd_enabled&nbsp;: <code class="type">bool Pervasives.ref</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>The enable flag. Set to default value</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>fd_name&nbsp;: <code class="type">string</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>This is used to construct an option "--doxxx" and "--dontxxx" that 
 enable and disable the feature</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>fd_description&nbsp;: <code class="type">string</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>fd_extraopt&nbsp;: <code class="type">(string * Arg.spec * string) list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Additional command line options</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>fd_doit&nbsp;: <code class="type"><a href="Cil.html#TYPEfile">file</a> -> unit</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>This performs the transformation</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>fd_post_check&nbsp;: <code class="type">bool</code>;</code></td>

</tr></table>
}

<div class="info">
To be able to add/remove features easily, each feature should be package 
 as an interface with the following interface. These features should be<br>
</div>

<pre><span class="keyword">val</span> <a name="VALcompareLoc"></a>compareLoc : <code class="type"><a href="Cil.html#TYPElocation">location</a> -> <a href="Cil.html#TYPElocation">location</a> -> int</code></pre><div class="info">
Comparison function for locations.
* Compares first by filename, then line, then byte<br>
</div>
<br>
<b>Values for manipulating globals</b><br>
<pre><span class="keyword">val</span> <a name="VALemptyFunction"></a>emptyFunction : <code class="type">string -> <a href="Cil.html#TYPEfundec">fundec</a></code></pre><div class="info">
Make an empty function<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsetFormals"></a>setFormals : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> -> <a href="Cil.html#TYPEvarinfo">varinfo</a> list -> unit</code></pre><div class="info">
Update the formals of a <code class="code">fundec</code> and make sure that the function type 
    has the same information. Will copy the name as well into the type.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsetFunctionType"></a>setFunctionType : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> -> <a href="Cil.html#TYPEtyp">typ</a> -> unit</code></pre><div class="info">
Set the types of arguments and results as given by the function type 
 passed as the second argument. Will not copy the names from the function 
 type to the formals<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsetFunctionTypeMakeFormals"></a>setFunctionTypeMakeFormals : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> -> <a href="Cil.html#TYPEtyp">typ</a> -> unit</code></pre><div class="info">
Set the type of the function and make formal arguments for them<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsetMaxId"></a>setMaxId : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> -> unit</code></pre><div class="info">
Update the smaxid after you have populated with locals and formals 
 (unless you constructed those using <a href="Cil.html#VALmakeLocalVar"><code class="code">Cil.makeLocalVar</code></a> or 
 <a href="Cil.html#VALmakeTempVar"><code class="code">Cil.makeTempVar</code></a>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdummyFunDec"></a>dummyFunDec : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a></code></pre><div class="info">
A dummy function declaration handy when you need one as a placeholder. It 
 contains inside a dummy varinfo.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdummyFile"></a>dummyFile : <code class="type"><a href="Cil.html#TYPEfile">file</a></code></pre><div class="info">
A dummy file<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsaveBinaryFile"></a>saveBinaryFile : <code class="type"><a href="Cil.html#TYPEfile">file</a> -> string -> unit</code></pre><div class="info">
Write a <a href="Cil.html#TYPEfile"><code class="code">Cil.file</code></a> in binary form to the filesystem. The file can be
 read back in later using <a href="Cil.html#VALloadBinaryFile"><code class="code">Cil.loadBinaryFile</code></a>, possibly saving parsing
 time. The second argument is the name of the file that should be
 created.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsaveBinaryFileChannel"></a>saveBinaryFileChannel : <code class="type"><a href="Cil.html#TYPEfile">file</a> -> Pervasives.out_channel -> unit</code></pre><div class="info">
Write a <a href="Cil.html#TYPEfile"><code class="code">Cil.file</code></a> in binary form to the filesystem. The file can be
 read back in later using <a href="Cil.html#VALloadBinaryFile"><code class="code">Cil.loadBinaryFile</code></a>, possibly saving parsing
 time. Does not close the channel.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALloadBinaryFile"></a>loadBinaryFile : <code class="type">string -> <a href="Cil.html#TYPEfile">file</a></code></pre><div class="info">
Read a <a href="Cil.html#TYPEfile"><code class="code">Cil.file</code></a> in binary form from the filesystem. The first
 argument is the name of a file previously created by
 <a href="Cil.html#VALsaveBinaryFile"><code class="code">Cil.saveBinaryFile</code></a>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALgetGlobInit"></a>getGlobInit : <code class="type">?main_name:string -> <a href="Cil.html#TYPEfile">file</a> -> <a href="Cil.html#TYPEfundec">fundec</a></code></pre><div class="info">
Get the global initializer and create one if it does not already exist. 
 When it creates a global initializer it attempts to place a call to it in 
 the main function named by the optional argument (default "main")<br>
</div>
<pre><span class="keyword">val</span> <a name="VALiterGlobals"></a>iterGlobals : <code class="type"><a href="Cil.html#TYPEfile">file</a> -> (<a href="Cil.html#TYPEglobal">global</a> -> unit) -> unit</code></pre><div class="info">
Iterate over all globals, including the global initializer<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfoldGlobals"></a>foldGlobals : <code class="type"><a href="Cil.html#TYPEfile">file</a> -> ('a -> <a href="Cil.html#TYPEglobal">global</a> -> 'a) -> 'a -> 'a</code></pre><div class="info">
Fold over all globals, including the global initializer<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmapGlobals"></a>mapGlobals : <code class="type"><a href="Cil.html#TYPEfile">file</a> -> (<a href="Cil.html#TYPEglobal">global</a> -> <a href="Cil.html#TYPEglobal">global</a>) -> unit</code></pre><div class="info">
Map over all globals, including the global initializer and change things 
    in place<br>
</div>
<pre><span class="keyword">val</span> <a name="VALnew_sid"></a>new_sid : <code class="type">unit -> int</code></pre><pre><span class="keyword">val</span> <a name="VALprepareCFG"></a>prepareCFG : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> -> unit</code></pre><div class="info">
Prepare a function for CFG information computation by
 <a href="Cil.html#VALcomputeCFGInfo"><code class="code">Cil.computeCFGInfo</code></a>. This function converts all <code class="code">Break</code>, <code class="code">Switch</code>,
 <code class="code">Default</code> and <code class="code">Continue</code> <a href="Cil.html#TYPEstmtkind"><code class="code">Cil.stmtkind</code></a>s and <a href="Cil.html#TYPElabel"><code class="code">Cil.label</code></a>s into <code class="code">If</code>s
 and <code class="code">Goto</code>s, giving the function body a very CFG-like character. This
 function modifies its argument in place.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcomputeCFGInfo"></a>computeCFGInfo : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> -> bool -> unit</code></pre><div class="info">
Compute the CFG information for all statements in a fundec and return a 
 list of the statements. The input fundec cannot have <code class="code">Break</code>, <code class="code">Switch</code>, 
 <code class="code">Default</code>, or <code class="code">Continue</code> <a href="Cil.html#TYPEstmtkind"><code class="code">Cil.stmtkind</code></a>s or <a href="Cil.html#TYPElabel"><code class="code">Cil.label</code></a>s. Use
 <a href="Cil.html#VALprepareCFG"><code class="code">Cil.prepareCFG</code></a> to transform them away.  The second argument should
 be <code class="code">true</code> if you wish a global statement number, <code class="code">false</code> if you wish a
 local (per-function) statement numbering. The list of statements is set 
 in the sallstmts field of a fundec. 
<p>

 NOTE: unless you want the simpler control-flow graph provided by
 prepareCFG, or you need the function's smaxstmtid and sallstmt fields
 filled in, we recommend you use <a href="Cfg.html#VALcomputeFileCFG"><code class="code">Cfg.computeFileCFG</code></a> instead of this
 function to compute control-flow information.
 <a href="Cfg.html#VALcomputeFileCFG"><code class="code">Cfg.computeFileCFG</code></a> is newer and will handle switch, break, and
 continue correctly.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcopyFunction"></a>copyFunction : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> -> string -> <a href="Cil.html#TYPEfundec">fundec</a></code></pre><div class="info">
Create a deep copy of a function. There should be no sharing between the 
 copy and the original function<br>
</div>
<pre><span class="keyword">val</span> <a name="VALpushGlobal"></a>pushGlobal : <code class="type"><a href="Cil.html#TYPEglobal">global</a> -><br>       types:<a href="Cil.html#TYPEglobal">global</a> list Pervasives.ref -><br>       variables:<a href="Cil.html#TYPEglobal">global</a> list Pervasives.ref -> unit</code></pre><div class="info">
CIL keeps the types at the beginning of the file and the variables at the 
 end of the file. This function will take a global and add it to the 
 corresponding stack. Its operation is actually more complicated because if 
 the global declares a type that contains references to variables (e.g. in 
 sizeof in an array length) then it will also add declarations for the 
 variables to the types stack<br>
</div>
<pre><span class="keyword">val</span> <a name="VALinvalidStmt"></a>invalidStmt : <code class="type"><a href="Cil.html#TYPEstmt">stmt</a></code></pre><div class="info">
An empty statement. Used in pretty printing<br>
</div>
<pre><span class="keyword">val</span> <a name="VALgccBuiltins"></a>gccBuiltins : <code class="type">(string, <a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEtyp">typ</a> list * bool) Hashtbl.t</code></pre><div class="info">
A list of the GCC built-in functions. Maps the name to the result and 
 argument types, and whether it is vararg<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmsvcBuiltins"></a>msvcBuiltins : <code class="type">(string, <a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEtyp">typ</a> list * bool) Hashtbl.t</code></pre><div class="info">
A list of the MSVC built-in functions. Maps the name to the result and 
 argument types, and whether it is vararg<br>
</div>
<br>
<b>Values for manipulating initializers</b><br>
<pre><span class="keyword">val</span> <a name="VALmakeZeroInit"></a>makeZeroInit : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEinit">init</a></code></pre><div class="info">
Make a initializer for zero-ing a data type<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfoldLeftCompound"></a>foldLeftCompound : <code class="type">doinit:(<a href="Cil.html#TYPEoffset">offset</a> -> <a href="Cil.html#TYPEinit">init</a> -> <a href="Cil.html#TYPEtyp">typ</a> -> 'a -> 'a) -><br>       ct:<a href="Cil.html#TYPEtyp">typ</a> -> initl:(<a href="Cil.html#TYPEoffset">offset</a> * <a href="Cil.html#TYPEinit">init</a>) list -> acc:'a -> 'a</code></pre><div class="info">
Fold over the list of initializers in a Compound. <code class="code">doinit</code> is called on 
 every present initializer, even if it is of compound type. In the case of 
 arrays there might be missing zero-initializers at the end of the list. 
 These are not scanned. This is much like <code class="code">List.fold_left</code> except we also 
 pass the type of the initializer<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfoldLeftCompoundAll"></a>foldLeftCompoundAll : <code class="type">doinit:(<a href="Cil.html#TYPEoffset">offset</a> -> <a href="Cil.html#TYPEinit">init</a> -> <a href="Cil.html#TYPEtyp">typ</a> -> 'a -> 'a) -><br>       ct:<a href="Cil.html#TYPEtyp">typ</a> -> initl:(<a href="Cil.html#TYPEoffset">offset</a> * <a href="Cil.html#TYPEinit">init</a>) list -> acc:'a -> 'a</code></pre><div class="info">
Fold over the list of initializers in a Compound, like 
 <a href="Cil.html#VALfoldLeftCompound"><code class="code">Cil.foldLeftCompound</code></a> but in the case of an array it scans even missing 
 zero initializers at the end of the array<br>
</div>
<br>
<b>Values for manipulating types</b><br>
<pre><span class="keyword">val</span> <a name="VALvoidType"></a>voidType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info">
void<br>
</div>
<pre><span class="keyword">val</span> <a name="VALisVoidType"></a>isVoidType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALisVoidPtrType"></a>isVoidPtrType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALintType"></a>intType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info">
int<br>
</div>
<pre><span class="keyword">val</span> <a name="VALuintType"></a>uintType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info">
unsigned int<br>
</div>
<pre><span class="keyword">val</span> <a name="VALlongType"></a>longType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info">
long<br>
</div>
<pre><span class="keyword">val</span> <a name="VALulongType"></a>ulongType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info">
unsigned long<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcharType"></a>charType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info">
char<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcharPtrType"></a>charPtrType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info">
char *<br>
</div>
<pre><span class="keyword">val</span> <a name="VALwcharKind"></a>wcharKind : <code class="type"><a href="Cil.html#TYPEikind">ikind</a> Pervasives.ref</code></pre><div class="info">
wchar_t (depends on architecture) and is set when you call 
 <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALwcharType"></a>wcharType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> Pervasives.ref</code></pre><pre><span class="keyword">val</span> <a name="VALcharConstPtrType"></a>charConstPtrType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info">
char const *<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvoidPtrType"></a>voidPtrType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info">
void *<br>
</div>
<pre><span class="keyword">val</span> <a name="VALintPtrType"></a>intPtrType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info">
int *<br>
</div>
<pre><span class="keyword">val</span> <a name="VALuintPtrType"></a>uintPtrType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info">
unsigned int *<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdoubleType"></a>doubleType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info">
double<br>
</div>
<pre><span class="keyword">val</span> <a name="VALupointType"></a>upointType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> Pervasives.ref</code></pre><pre><span class="keyword">val</span> <a name="VALtypeOfSizeOf"></a>typeOfSizeOf : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> Pervasives.ref</code></pre><pre><span class="keyword">val</span> <a name="VALisSigned"></a>isSigned : <code class="type"><a href="Cil.html#TYPEikind">ikind</a> -> bool</code></pre><div class="info">
Returns true if and only if the given integer type is signed.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmkCompInfo"></a>mkCompInfo : <code class="type">bool -><br>       string -><br>       (<a href="Cil.html#TYPEcompinfo">compinfo</a> -><br>        (string * <a href="Cil.html#TYPEtyp">typ</a> * int option * <a href="Cil.html#TYPEattributes">attributes</a> * <a href="Cil.html#TYPElocation">location</a>) list) -><br>       <a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Cil.html#TYPEcompinfo">compinfo</a></code></pre><div class="info">
Creates a a (potentially recursive) composite type. The arguments are: 
 (1) a boolean indicating whether it is a struct or a union, (2) the name 
 (always non-empty), (3) a function that when given a representation of the 
 structure type constructs the type of the fields recursive type (the first 
 argument is only useful when some fields need to refer to the type of the 
 structure itself), and (4) a list of attributes to be associated with the 
 composite type. The resulting compinfo has the field "cdefined" only if 
 the list of fields is non-empty.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcopyCompInfo"></a>copyCompInfo : <code class="type"><a href="Cil.html#TYPEcompinfo">compinfo</a> -> string -> <a href="Cil.html#TYPEcompinfo">compinfo</a></code></pre><div class="info">
Makes a shallow copy of a <a href="Cil.html#TYPEcompinfo"><code class="code">Cil.compinfo</code></a> changing the name and the key.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmissingFieldName"></a>missingFieldName : <code class="type">string</code></pre><div class="info">
This is a constant used as the name of an unnamed bitfield. These fields
    do not participate in initialization and their name is not printed.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcompFullName"></a>compFullName : <code class="type"><a href="Cil.html#TYPEcompinfo">compinfo</a> -> string</code></pre><div class="info">
Get the full name of a comp<br>
</div>
<pre><span class="keyword">val</span> <a name="VALisCompleteType"></a>isCompleteType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> bool</code></pre><div class="info">
Returns true if this is a complete type. 
   This means that sizeof(t) makes sense. 
   Incomplete types are not yet defined 
   structures and empty arrays.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALunrollType"></a>unrollType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info">
Unroll a type until it exposes a non 
 <code class="code">TNamed</code>. Will collect all attributes appearing in <code class="code">TNamed</code>!!!<br>
</div>
<pre><span class="keyword">val</span> <a name="VALunrollTypeDeep"></a>unrollTypeDeep : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info">
Unroll all the TNamed in a type (even under type constructors such as 
 <code class="code">TPtr</code>, <code class="code">TFun</code> or <code class="code">TArray</code>. Does not unroll the types of fields in <code class="code">TComp</code> 
 types. Will collect all attributes<br>
</div>
<pre><span class="keyword">val</span> <a name="VALseparateStorageModifiers"></a>separateStorageModifiers : <code class="type"><a href="Cil.html#TYPEattribute">attribute</a> list -> <a href="Cil.html#TYPEattribute">attribute</a> list * <a href="Cil.html#TYPEattribute">attribute</a> list</code></pre><div class="info">
Separate out the storage-modifier name attributes<br>
</div>
<pre><span class="keyword">val</span> <a name="VALisIntegralType"></a>isIntegralType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> bool</code></pre><div class="info">
True if the argument is an integral type (i.e. integer or enum)<br>
</div>
<pre><span class="keyword">val</span> <a name="VALisArithmeticType"></a>isArithmeticType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> bool</code></pre><div class="info">
True if the argument is an arithmetic type (i.e. integer, enum or 
    floating point<br>
</div>
<pre><span class="keyword">val</span> <a name="VALisPointerType"></a>isPointerType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> bool</code></pre><div class="info">
True if the argument is a pointer type<br>
</div>
<pre><span class="keyword">val</span> <a name="VALisFunctionType"></a>isFunctionType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> bool</code></pre><div class="info">
True if the argument is a function type<br>
</div>
<pre><span class="keyword">val</span> <a name="VALargsToList"></a>argsToList : <code class="type">(string * <a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEattributes">attributes</a>) list option -><br>       (string * <a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEattributes">attributes</a>) list</code></pre><div class="info">
Obtain the argument list ([] if None)<br>
</div>
<pre><span class="keyword">val</span> <a name="VALisArrayType"></a>isArrayType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> bool</code></pre><div class="info">
True if the argument is an array type<br>
</div>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONLenOfArray"></a>LenOfArray</pre>
<div class="info">
Raised when <a href="Cil.html#VALlenOfArray"><code class="code">Cil.lenOfArray</code></a> fails either because the length is <code class="code">None</code> 
 or because it is a non-constant expression<br>
</div>
<pre><span class="keyword">val</span> <a name="VALlenOfArray"></a>lenOfArray : <code class="type"><a href="Cil.html#TYPEexp">exp</a> option -> int</code></pre><div class="info">
Call to compute the array length as present in the array type, to an 
 integer. Raises <a href="Cil.html#EXCEPTIONLenOfArray"><code class="code">Cil.LenOfArray</code></a> if not able to compute the length, such 
 as when there is no length or the length is not a constant.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALgetCompField"></a>getCompField : <code class="type"><a href="Cil.html#TYPEcompinfo">compinfo</a> -> string -> <a href="Cil.html#TYPEfieldinfo">fieldinfo</a></code></pre><div class="info">
Return a named fieldinfo in compinfo, or raise Not_found<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEexistsAction"></a><code class="type"></code>existsAction = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">ExistsTrue</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">ExistsFalse</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">ExistsMaybe</span></code></td>

</tr></table>

<div class="info">
A datatype to be used in conjunction with <code class="code">existsType</code><br>
</div>

<pre><span class="keyword">val</span> <a name="VALexistsType"></a>existsType : <code class="type">(<a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEexistsAction">existsAction</a>) -> <a href="Cil.html#TYPEtyp">typ</a> -> bool</code></pre><div class="info">
Scans a type by applying the function on all elements. 
    When the function returns ExistsTrue, the scan stops with
    true. When the function returns ExistsFalse then the current branch is not
    scanned anymore. Care is taken to 
    apply the function only once on each composite type, thus avoiding 
    circularity. When the function returns ExistsMaybe then the types that 
    construct the current type are scanned (e.g. the base type for TPtr and 
    TArray, the type of fields for a TComp, etc).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsplitFunctionType"></a>splitFunctionType : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -><br>       <a href="Cil.html#TYPEtyp">typ</a> * (string * <a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEattributes">attributes</a>) list option * bool *<br>       <a href="Cil.html#TYPEattributes">attributes</a></code></pre><div class="info">
Given a function type split it into return type, 
 arguments, is_vararg and attributes. An error is raised if the type is not 
 a function type
<p>
Same as <a href="Cil.html#VALsplitFunctionType"><code class="code">Cil.splitFunctionType</code></a> but takes a varinfo. Prints a nicer 
 error message if the varinfo is not for a function<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsplitFunctionTypeVI"></a>splitFunctionTypeVI : <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo</a> -><br>       <a href="Cil.html#TYPEtyp">typ</a> * (string * <a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEattributes">attributes</a>) list option * bool *<br>       <a href="Cil.html#TYPEattributes">attributes</a></code></pre><br>
<b>Type signatures</b><br>
<br>
Type signatures. Two types are identical iff they have identical 
 signatures. These contain the same information as types but canonicalized. 
 For example, two function types that are identical except for the name of 
 the formal arguments are given the same signature. Also, <code class="code">TNamed</code> 
 constructors are unrolled. You shoud use <code class="code">Util.equals</code> to compare type 
 signatures because they might still contain circular structures (through 
 attributes, and sizeof)<br>
<pre><span class="keyword">val</span> <a name="VALd_typsig"></a>d_typsig : <code class="type">unit -> <a href="Cil.html#TYPEtypsig">typsig</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Print a type signature<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtypeSig"></a>typeSig : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEtypsig">typsig</a></code></pre><div class="info">
Compute a type signature<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtypeSigWithAttrs"></a>typeSigWithAttrs : <code class="type">?ignoreSign:bool -><br>       (<a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Cil.html#TYPEattributes">attributes</a>) -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEtypsig">typsig</a></code></pre><div class="info">
Like <a href="Cil.html#VALtypeSig"><code class="code">Cil.typeSig</code></a> but customize the incorporation of attributes.
    Use ~ignoreSign:true to convert all signed integer types to unsigned,
    so that signed and unsigned will compare the same.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsetTypeSigAttrs"></a>setTypeSigAttrs : <code class="type"><a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Cil.html#TYPEtypsig">typsig</a> -> <a href="Cil.html#TYPEtypsig">typsig</a></code></pre><div class="info">
Replace the attributes of a signature (only at top level)<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtypeSigAttrs"></a>typeSigAttrs : <code class="type"><a href="Cil.html#TYPEtypsig">typsig</a> -> <a href="Cil.html#TYPEattributes">attributes</a></code></pre><div class="info">
Get the top-level attributes of a signature<br>
</div>
<br>
LVALUES<br>
<pre><span class="keyword">val</span> <a name="VALmakeVarinfo"></a>makeVarinfo : <code class="type">bool -> string -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEvarinfo">varinfo</a></code></pre><div class="info">
Make a varinfo. Use this (rarely) to make a raw varinfo. Use other 
 functions to make locals (<a href="Cil.html#VALmakeLocalVar"><code class="code">Cil.makeLocalVar</code></a> or <a href="Cil.html#VALmakeFormalVar"><code class="code">Cil.makeFormalVar</code></a> or 
 <a href="Cil.html#VALmakeTempVar"><code class="code">Cil.makeTempVar</code></a>) and globals (<a href="Cil.html#VALmakeGlobalVar"><code class="code">Cil.makeGlobalVar</code></a>). Note that this 
 function will assign a new identifier. The first argument specifies 
 whether the varinfo is for a global.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmakeFormalVar"></a>makeFormalVar : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> -> ?where:string -> string -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEvarinfo">varinfo</a></code></pre><div class="info">
Make a formal variable for a function. Insert it in both the sformals 
    and the type of the function. You can optionally specify where to insert 
    this one. If where = "^" then it is inserted first. If where = "$" then 
    it is inserted last. Otherwise where must be the name of a formal after 
    which to insert this. By default it is inserted at the end.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmakeLocalVar"></a>makeLocalVar : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> -> ?insert:bool -> string -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEvarinfo">varinfo</a></code></pre><div class="info">
Make a local variable and add it to a function's slocals (only if insert = 
    true, which is the default). Make sure you know what you are doing if you 
    set insert=false.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmakeTempVar"></a>makeTempVar : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> -> ?name:string -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEvarinfo">varinfo</a></code></pre><div class="info">
Make a temporary variable and add it to a function's slocals. The name of 
    the temporary variable will be generated based on the given name hint so 
    that to avoid conflicts with other locals.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmakeGlobalVar"></a>makeGlobalVar : <code class="type">string -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEvarinfo">varinfo</a></code></pre><div class="info">
Make a global variable. Your responsibility to make sure that the name 
    is unique<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcopyVarinfo"></a>copyVarinfo : <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo</a> -> string -> <a href="Cil.html#TYPEvarinfo">varinfo</a></code></pre><div class="info">
Make a shallow copy of a <code class="code">varinfo</code> and assign a new identifier<br>
</div>
<pre><span class="keyword">val</span> <a name="VALnewVID"></a>newVID : <code class="type">unit -> int</code></pre><div class="info">
Generate a new variable ID. This will be different than any variable ID 
 that is generated by <a href="Cil.html#VALmakeLocalVar"><code class="code">Cil.makeLocalVar</code></a> and friends<br>
</div>
<pre><span class="keyword">val</span> <a name="VALaddOffsetLval"></a>addOffsetLval : <code class="type"><a href="Cil.html#TYPEoffset">offset</a> -> <a href="Cil.html#TYPElval">lval</a> -> <a href="Cil.html#TYPElval">lval</a></code></pre><div class="info">
Add an offset at the end of an lvalue. Make sure the type of the lvalue 
 and the offset are compatible.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALaddOffset"></a>addOffset : <code class="type"><a href="Cil.html#TYPEoffset">offset</a> -> <a href="Cil.html#TYPEoffset">offset</a> -> <a href="Cil.html#TYPEoffset">offset</a></code></pre><div class="info">
<code class="code">addOffset o1 o2</code> adds <code class="code">o1</code> to the end of <code class="code">o2</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALremoveOffsetLval"></a>removeOffsetLval : <code class="type"><a href="Cil.html#TYPElval">lval</a> -> <a href="Cil.html#TYPElval">lval</a> * <a href="Cil.html#TYPEoffset">offset</a></code></pre><div class="info">
Remove ONE offset from the end of an lvalue. Returns the lvalue with the 
 trimmed offset and the final offset. If the final offset is <code class="code">NoOffset</code> 
 then the original <code class="code">lval</code> did not have an offset.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALremoveOffset"></a>removeOffset : <code class="type"><a href="Cil.html#TYPEoffset">offset</a> -> <a href="Cil.html#TYPEoffset">offset</a> * <a href="Cil.html#TYPEoffset">offset</a></code></pre><div class="info">
Remove ONE offset from the end of an offset sequence. Returns the 
 trimmed offset and the final offset. If the final offset is <code class="code">NoOffset</code> 
 then the original <code class="code">lval</code> did not have an offset.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtypeOfLval"></a>typeOfLval : <code class="type"><a href="Cil.html#TYPElval">lval</a> -> <a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info">
Compute the type of an lvalue<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtypeOffset"></a>typeOffset : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEoffset">offset</a> -> <a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info">
Compute the type of an offset from a base type<br>
</div>
<br>
<b>Values for manipulating expressions</b><br>
<pre><span class="keyword">val</span> <a name="VALzero"></a>zero : <code class="type"><a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info">
0<br>
</div>
<pre><span class="keyword">val</span> <a name="VALone"></a>one : <code class="type"><a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info">
1<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmone"></a>mone : <code class="type"><a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info">
-1<br>
</div>
<pre><span class="keyword">val</span> <a name="VALkinteger64"></a>kinteger64 : <code class="type"><a href="Cil.html#TYPEikind">ikind</a> -> int64 -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info">
Construct an integer of a given kind, using OCaml's int64 type. If needed 
 it will truncate the integer to be within the representable range for the 
 given kind.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALkinteger"></a>kinteger : <code class="type"><a href="Cil.html#TYPEikind">ikind</a> -> int -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info">
Construct an integer of a given kind. Converts the integer to int64 and 
 then uses kinteger64. This might truncate the value if you use a kind 
 that cannot represent the given integer. This can only happen for one of 
 the Char or Short kinds<br>
</div>
<pre><span class="keyword">val</span> <a name="VALinteger"></a>integer : <code class="type">int -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info">
Construct an integer of kind IInt. You can use this always since the 
    OCaml integers are 31 bits and are guaranteed to fit in an IInt<br>
</div>
<pre><span class="keyword">val</span> <a name="VALisInteger"></a>isInteger : <code class="type"><a href="Cil.html#TYPEexp">exp</a> -> int64 option</code></pre><div class="info">
True if the given expression is a (possibly cast'ed) 
    character or an integer constant<br>
</div>
<pre><span class="keyword">val</span> <a name="VALisConstant"></a>isConstant : <code class="type"><a href="Cil.html#TYPEexp">exp</a> -> bool</code></pre><div class="info">
True if the expression is a compile-time constant<br>
</div>
<pre><span class="keyword">val</span> <a name="VALisZero"></a>isZero : <code class="type"><a href="Cil.html#TYPEexp">exp</a> -> bool</code></pre><div class="info">
True if the given expression is a (possibly cast'ed) integer or character 
    constant with value zero<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcharConstToInt"></a>charConstToInt : <code class="type">char -> <a href="Cil.html#TYPEconstant">constant</a></code></pre><div class="info">
Given the character c in a (CChr c), sign-extend it to 32 bits.
  (This is the official way of interpreting character constants, according to
  ISO C 6.4.4.4.10, which says that character constants are chars cast to ints)
  Returns CInt64(sign-extened c, IInt, None)<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconstFold"></a>constFold : <code class="type">bool -> <a href="Cil.html#TYPEexp">exp</a> -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info">
Do constant folding on an expression. If the first argument is true then 
    will also compute compiler-dependent expressions such as sizeof<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconstFoldBinOp"></a>constFoldBinOp : <code class="type">bool -> <a href="Cil.html#TYPEbinop">binop</a> -> <a href="Cil.html#TYPEexp">exp</a> -> <a href="Cil.html#TYPEexp">exp</a> -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info">
Do constant folding on a binary operation. The bulk of the work done by 
    <code class="code">constFold</code> is done here. If the first argument is true then 
    will also compute compiler-dependent expressions such as sizeof<br>
</div>
<pre><span class="keyword">val</span> <a name="VALincrem"></a>increm : <code class="type"><a href="Cil.html#TYPEexp">exp</a> -> int -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info">
Increment an expression. Can be arithmetic or pointer type<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvar"></a>var : <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo</a> -> <a href="Cil.html#TYPElval">lval</a></code></pre><div class="info">
Makes an lvalue out of a given variable<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmkAddrOf"></a>mkAddrOf : <code class="type"><a href="Cil.html#TYPElval">lval</a> -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info">
Make an AddrOf. Given an lvalue of type T will give back an expression of 
    type ptr(T). It optimizes somewhat expressions like "&amp; v" and "&amp; v<code class="code">0</code>"<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmkAddrOrStartOf"></a>mkAddrOrStartOf : <code class="type"><a href="Cil.html#TYPElval">lval</a> -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info">
Like mkAddrOf except if the type of lval is an array then it uses 
    StartOf. This is the right operation for getting a pointer to the start 
    of the storage denoted by lval.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmkMem"></a>mkMem : <code class="type">addr:<a href="Cil.html#TYPEexp">exp</a> -> off:<a href="Cil.html#TYPEoffset">offset</a> -> <a href="Cil.html#TYPElval">lval</a></code></pre><div class="info">
Make a Mem, while optimizing AddrOf. The type of the addr must be 
    TPtr(t) and the type of the resulting lval is t. Note that in CIL the 
    implicit conversion between an array and the pointer to the first 
    element does not apply. You must do the conversion yourself using 
    StartOf<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmkString"></a>mkString : <code class="type">string -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info">
Make an expression that is a string constant (of pointer type)<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmkCastT"></a>mkCastT : <code class="type">e:<a href="Cil.html#TYPEexp">exp</a> -> oldt:<a href="Cil.html#TYPEtyp">typ</a> -> newt:<a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info">
Construct a cast when having the old type of the expression. If the new 
 type is the same as the old type, then no cast is added.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmkCast"></a>mkCast : <code class="type">e:<a href="Cil.html#TYPEexp">exp</a> -> newt:<a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info">
Like <a href="Cil.html#VALmkCastT"><code class="code">Cil.mkCastT</code></a> but uses typeOf to get <code class="code">oldt</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALstripCasts"></a>stripCasts : <code class="type"><a href="Cil.html#TYPEexp">exp</a> -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info">
Removes casts from this expression, but ignores casts within
  other expression constructs.  So we delete the (A) and (B) casts from 
  "(A)(B)(x + (C)y)", but leave the (C) cast.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtypeOf"></a>typeOf : <code class="type"><a href="Cil.html#TYPEexp">exp</a> -> <a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info">
Compute the type of an expression<br>
</div>
<pre><span class="keyword">val</span> <a name="VALparseInt"></a>parseInt : <code class="type">string -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info">
Convert a string representing a C integer literal to an expression. 
 Handles the prefixes 0x and 0 and the suffixes L, U, UL, LL, ULL<br>
</div>
<br>
<b>Values for manipulating statements</b><br>
<pre><span class="keyword">val</span> <a name="VALmkStmt"></a>mkStmt : <code class="type"><a href="Cil.html#TYPEstmtkind">stmtkind</a> -> <a href="Cil.html#TYPEstmt">stmt</a></code></pre><div class="info">
Construct a statement, given its kind. Initialize the <code class="code">sid</code> field to -1,
    and <code class="code">labels</code>, <code class="code">succs</code> and <code class="code">preds</code> to the empty list<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmkBlock"></a>mkBlock : <code class="type"><a href="Cil.html#TYPEstmt">stmt</a> list -> <a href="Cil.html#TYPEblock">block</a></code></pre><div class="info">
Construct a block with no attributes, given a list of statements<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmkStmtOneInstr"></a>mkStmtOneInstr : <code class="type"><a href="Cil.html#TYPEinstr">instr</a> -> <a href="Cil.html#TYPEstmt">stmt</a></code></pre><div class="info">
Construct a statement consisting of just one instruction<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcompactStmts"></a>compactStmts : <code class="type"><a href="Cil.html#TYPEstmt">stmt</a> list -> <a href="Cil.html#TYPEstmt">stmt</a> list</code></pre><div class="info">
Try to compress statements so as to get maximal basic blocks<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmkEmptyStmt"></a>mkEmptyStmt : <code class="type">unit -> <a href="Cil.html#TYPEstmt">stmt</a></code></pre><div class="info">
Returns an empty statement (of kind <code class="code">Instr</code>)<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdummyInstr"></a>dummyInstr : <code class="type"><a href="Cil.html#TYPEinstr">instr</a></code></pre><div class="info">
A instr to serve as a placeholder<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdummyStmt"></a>dummyStmt : <code class="type"><a href="Cil.html#TYPEstmt">stmt</a></code></pre><div class="info">
A statement consisting of just <code class="code">dummyInstr</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALmkWhile"></a>mkWhile : <code class="type">guard:<a href="Cil.html#TYPEexp">exp</a> -> body:<a href="Cil.html#TYPEstmt">stmt</a> list -> <a href="Cil.html#TYPEstmt">stmt</a> list</code></pre><div class="info">
Make a while loop. Can contain Break or Continue<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmkForIncr"></a>mkForIncr : <code class="type">iter:<a href="Cil.html#TYPEvarinfo">varinfo</a> -><br>       first:<a href="Cil.html#TYPEexp">exp</a> -><br>       stopat:<a href="Cil.html#TYPEexp">exp</a> -> incr:<a href="Cil.html#TYPEexp">exp</a> -> body:<a href="Cil.html#TYPEstmt">stmt</a> list -> <a href="Cil.html#TYPEstmt">stmt</a> list</code></pre><div class="info">
Make a for loop for(i=start; i&lt;past; i += incr) { ... }. The body 
    can contain Break but not Continue. Can be used with i a pointer 
    or an integer. Start and done must have the same type but incr 
    must be an integer<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmkFor"></a>mkFor : <code class="type">start:<a href="Cil.html#TYPEstmt">stmt</a> list -><br>       guard:<a href="Cil.html#TYPEexp">exp</a> -> next:<a href="Cil.html#TYPEstmt">stmt</a> list -> body:<a href="Cil.html#TYPEstmt">stmt</a> list -> <a href="Cil.html#TYPEstmt">stmt</a> list</code></pre><div class="info">
Make a for loop for(start; guard; next) { ... }. The body can 
    contain Break but not Continue !!!<br>
</div>
<br>
<b>Values for manipulating attributes</b><br>
<br><code><span class="keyword">type</span> <a name="TYPEattributeClass"></a><code class="type"></code>attributeClass = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">AttrName</span> <span class="keyword">of</span> <code class="type">bool</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Attribute of a name. If argument is true and we are on MSVC then 
            the attribute is printed using __declspec as part of the storage 
            specifier</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">AttrFunType</span> <span class="keyword">of</span> <code class="type">bool</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Attribute of a function type. If argument is true and we are on 
            MSVC then the attribute is printed just before the function name</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">AttrType</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Attribute of a type</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
Various classes of attributes<br>
</div>

<pre><span class="keyword">val</span> <a name="VALattributeHash"></a>attributeHash : <code class="type">(string, <a href="Cil.html#TYPEattributeClass">attributeClass</a>) Hashtbl.t</code></pre><div class="info">
This table contains the mapping of predefined attributes to classes. 
    Extend this table with more attributes as you need. This table is used to 
    determine how to associate attributes with names or types<br>
</div>
<pre><span class="keyword">val</span> <a name="VALpartitionAttributes"></a>partitionAttributes : <code class="type">default:<a href="Cil.html#TYPEattributeClass">attributeClass</a> -><br>       <a href="Cil.html#TYPEattributes">attributes</a> -><br>       <a href="Cil.html#TYPEattribute">attribute</a> list * <a href="Cil.html#TYPEattribute">attribute</a> list * <a href="Cil.html#TYPEattribute">attribute</a> list</code></pre><div class="info">
Partition the attributes into classes:name attributes, function type, 
    and type attributes<br>
</div>
<pre><span class="keyword">val</span> <a name="VALaddAttribute"></a>addAttribute : <code class="type"><a href="Cil.html#TYPEattribute">attribute</a> -> <a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Cil.html#TYPEattributes">attributes</a></code></pre><div class="info">
Add an attribute. Maintains the attributes in sorted order of the second 
    argument<br>
</div>
<pre><span class="keyword">val</span> <a name="VALaddAttributes"></a>addAttributes : <code class="type"><a href="Cil.html#TYPEattribute">attribute</a> list -> <a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Cil.html#TYPEattributes">attributes</a></code></pre><div class="info">
Add a list of attributes. Maintains the attributes in sorted order. The 
    second argument must be sorted, but not necessarily the first<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdropAttribute"></a>dropAttribute : <code class="type">string -> <a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Cil.html#TYPEattributes">attributes</a></code></pre><div class="info">
Remove all attributes with the given name. Maintains the attributes in 
    sorted order.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdropAttributes"></a>dropAttributes : <code class="type">string list -> <a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Cil.html#TYPEattributes">attributes</a></code></pre><div class="info">
Remove all attributes with names appearing in the string list.
  Maintains the attributes in sorted order<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfilterAttributes"></a>filterAttributes : <code class="type">string -> <a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Cil.html#TYPEattributes">attributes</a></code></pre><div class="info">
Retains attributes with the given name<br>
</div>
<pre><span class="keyword">val</span> <a name="VALhasAttribute"></a>hasAttribute : <code class="type">string -> <a href="Cil.html#TYPEattributes">attributes</a> -> bool</code></pre><div class="info">
True if the named attribute appears in the attribute list. The list of
    attributes must be sorted.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtypeAttrs"></a>typeAttrs : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEattribute">attribute</a> list</code></pre><div class="info">
Returns all the attributes contained in a type. This requires a traversal 
    of the type structure, in case of composite, enumeration and named types<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsetTypeAttrs"></a>setTypeAttrs : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Cil.html#TYPEtyp">typ</a></code></pre><pre><span class="keyword">val</span> <a name="VALtypeAddAttributes"></a>typeAddAttributes : <code class="type"><a href="Cil.html#TYPEattribute">attribute</a> list -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info">
Add some attributes to a type<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtypeRemoveAttributes"></a>typeRemoveAttributes : <code class="type">string list -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info">
Remove all attributes with the given names from a type. Note that this
    does not remove attributes from typedef and tag definitions, just from 
    their uses<br>
</div>
<br>
<b>The visitor</b><br>
<br><code><span class="keyword">type</span> <a name="TYPEvisitAction"></a><code class="type">'a</code> visitAction = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SkipChildren</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Do not visit the children. Return 
                                            the node as it is.</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">DoChildren</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Continue with the children of this 
                                            node. Rebuild the node on return 
                                            if any of the children changes 
                                            (use == test)</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">ChangeTo</span> <span class="keyword">of</span> <code class="type">'a</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>Replace the expression with the 
                                            given one</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">ChangeDoChildrenPost</span> <span class="keyword">of</span> <code class="type">'a * ('a -> 'a)</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>First consider that the entire 
                                           exp is replaced by the first 
                                           parameter. Then continue with 
                                           the children. On return rebuild 
                                           the node if any of the children 
                                           has changed and then apply the 
                                           function on the node</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
Different visiting actions. 'a will be instantiated with <code class="code">exp</code>, <code class="code">instr</code>,
    etc.<br>
</div>

<pre><span class="keyword">class type</span> <a name="TYPEcilVisitor"></a><a href="Cil.cilVisitor.html">cilVisitor</a> = <code class="code">object</code> <a href="Cil.cilVisitor.html">..</a> <code class="code">end</code></pre><div class="info">
A visitor interface for traversing CIL trees.
</div>
<pre><span class="keyword">class</span> <a name="TYPEnopCilVisitor"></a><a href="Cil.nopCilVisitor.html">nopCilVisitor</a> : <code class="type"></code><code class="type"><a href="Cil.cilVisitor.html">cilVisitor</a></code></pre><div class="info">
Default Visitor.
</div>
<pre><span class="keyword">val</span> <a name="VALvisitCilFile"></a>visitCilFile : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor</a> -> <a href="Cil.html#TYPEfile">file</a> -> unit</code></pre><div class="info">
Visit a file. This will will re-cons all globals TWICE (so that it is 
 tail-recursive). Use <a href="Cil.html#VALvisitCilFileSameGlobals"><code class="code">Cil.visitCilFileSameGlobals</code></a> if your visitor will 
 not change the list of globals.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvisitCilFileSameGlobals"></a>visitCilFileSameGlobals : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor</a> -> <a href="Cil.html#TYPEfile">file</a> -> unit</code></pre><div class="info">
A visitor for the whole file that does not change the globals (but maybe
 changes things inside the globals). Use this function instead of
 <a href="Cil.html#VALvisitCilFile"><code class="code">Cil.visitCilFile</code></a> whenever appropriate because it is more efficient for
 long files.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvisitCilGlobal"></a>visitCilGlobal : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor</a> -> <a href="Cil.html#TYPEglobal">global</a> -> <a href="Cil.html#TYPEglobal">global</a> list</code></pre><div class="info">
Visit a global<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvisitCilFunction"></a>visitCilFunction : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor</a> -> <a href="Cil.html#TYPEfundec">fundec</a> -> <a href="Cil.html#TYPEfundec">fundec</a></code></pre><div class="info">
Visit a function definition<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvisitCilExpr"></a>visitCilExpr : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor</a> -> <a href="Cil.html#TYPEexp">exp</a> -> <a href="Cil.html#TYPEexp">exp</a></code></pre><pre><span class="keyword">val</span> <a name="VALvisitCilLval"></a>visitCilLval : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor</a> -> <a href="Cil.html#TYPElval">lval</a> -> <a href="Cil.html#TYPElval">lval</a></code></pre><div class="info">
Visit an lvalue<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvisitCilOffset"></a>visitCilOffset : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor</a> -> <a href="Cil.html#TYPEoffset">offset</a> -> <a href="Cil.html#TYPEoffset">offset</a></code></pre><div class="info">
Visit an lvalue or recursive offset<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvisitCilInitOffset"></a>visitCilInitOffset : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor</a> -> <a href="Cil.html#TYPEoffset">offset</a> -> <a href="Cil.html#TYPEoffset">offset</a></code></pre><div class="info">
Visit an initializer offset<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvisitCilInstr"></a>visitCilInstr : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor</a> -> <a href="Cil.html#TYPEinstr">instr</a> -> <a href="Cil.html#TYPEinstr">instr</a> list</code></pre><div class="info">
Visit an instruction<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvisitCilStmt"></a>visitCilStmt : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor</a> -> <a href="Cil.html#TYPEstmt">stmt</a> -> <a href="Cil.html#TYPEstmt">stmt</a></code></pre><div class="info">
Visit a statement<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvisitCilBlock"></a>visitCilBlock : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor</a> -> <a href="Cil.html#TYPEblock">block</a> -> <a href="Cil.html#TYPEblock">block</a></code></pre><div class="info">
Visit a block<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvisitCilType"></a>visitCilType : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor</a> -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info">
Visit a type<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvisitCilVarDecl"></a>visitCilVarDecl : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor</a> -> <a href="Cil.html#TYPEvarinfo">varinfo</a> -> <a href="Cil.html#TYPEvarinfo">varinfo</a></code></pre><div class="info">
Visit a variable declaration<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvisitCilInit"></a>visitCilInit : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor</a> -> <a href="Cil.html#TYPEinit">init</a> -> <a href="Cil.html#TYPEinit">init</a></code></pre><div class="info">
Visit an initializer<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvisitCilAttributes"></a>visitCilAttributes : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor</a> -> <a href="Cil.html#TYPEattribute">attribute</a> list -> <a href="Cil.html#TYPEattribute">attribute</a> list</code></pre><div class="info">
Visit a list of attributes<br>
</div>
<br>
<b>Utility functions</b><br>
<pre><span class="keyword">val</span> <a name="VALmsvcMode"></a>msvcMode : <code class="type">bool Pervasives.ref</code></pre><div class="info">
Whether the pretty printer should print output for the MS VC compiler.
   Default is GCC. After you set this function you should call <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALuseLogicalOperators"></a>useLogicalOperators : <code class="type">bool Pervasives.ref</code></pre><div class="info">
Whether to use the logical operands LAnd and LOr. By default, do not use 
 them because they are unlike other expressions and do not evaluate both of 
 their operands<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconstFoldVisitor"></a>constFoldVisitor : <code class="type">bool -> <a href="Cil.cilVisitor.html">cilVisitor</a></code></pre><div class="info">
A visitor that does constant folding. Pass as argument whether you want 
 machine specific simplifications to be done, or not.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPElineDirectiveStyle"></a><code class="type"></code>lineDirectiveStyle = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">LineComment</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">LinePreprocessorInput</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">LinePreprocessorOutput</span></code></td>

</tr></table>

<div class="info">
Styles of printing line directives<br>
</div>

<pre><span class="keyword">val</span> <a name="VALlineDirectiveStyle"></a>lineDirectiveStyle : <code class="type"><a href="Cil.html#TYPElineDirectiveStyle">lineDirectiveStyle</a> option Pervasives.ref</code></pre><div class="info">
How to print line directives<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprint_CIL_Input"></a>print_CIL_Input : <code class="type">bool Pervasives.ref</code></pre><div class="info">
Whether we print something that will only be used as input to our own 
 parser. In that case we are a bit more liberal in what we print<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprintCilAsIs"></a>printCilAsIs : <code class="type">bool Pervasives.ref</code></pre><div class="info">
Whether to print the CIL as they are, without trying to be smart and 
 print nicer code. Normally this is false, in which case the pretty 
 printer will turn the while(1) loops of CIL into nicer loops, will not 
 print empty "else" blocks, etc. These is one case howewer in which if you 
 turn this on you will get code that does not compile: if you use varargs 
 the __builtin_va_arg function will be printed in its internal form.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALlineLength"></a>lineLength : <code class="type">int Pervasives.ref</code></pre><div class="info">
The length used when wrapping output lines.  Setting this variable to
 a large integer will prevent wrapping and make #line directives more
 accurate.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALforgcc"></a>forgcc : <code class="type">string -> string</code></pre><div class="info">
Return the string 's' if we're printing output for gcc, suppres
  it if we're printing for CIL to parse back in.  the purpose is to
  hide things from gcc that it complains about, but still be able
  to do lossless transformations when CIL is the consumer<br>
</div>
<br>
<b>Debugging support</b><br>
<pre><span class="keyword">val</span> <a name="VALcurrentLoc"></a>currentLoc : <code class="type"><a href="Cil.html#TYPElocation">location</a> Pervasives.ref</code></pre><div class="info">
A reference to the current location. If you are careful to set this to 
 the current location then you can use some built-in logging functions that 
 will print the location.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcurrentGlobal"></a>currentGlobal : <code class="type"><a href="Cil.html#TYPEglobal">global</a> Pervasives.ref</code></pre><div class="info">
A reference to the current global being visited<br>
</div>
<br>
CIL has a fairly easy to use mechanism for printing error messages. This 
 mechanism is built on top of the pretty-printer mechanism (see 
 <a href="Pretty.html#TYPEdoc"><code class="code">Pretty.doc</code></a>) and the error-message modules (see <a href="Errormsg.html#VALerror"><code class="code">Errormsg.error</code></a>). 
<p>

 Here is a typical example for printing a log message: <pre>
ignore (Errormsg.log "Expression %a is not positive (at %s:%i)\n"
                        d_exp e loc.file loc.line)
</pre>
<p>

 and here is an example of how you print a fatal error message that stop the 
 execution: <pre>
Errormsg.s (Errormsg.bug "Why am I here?")
</pre>
<p>

 Notice that you can use C format strings with some extension. The most 
useful extension is "%a" that means to consumer the next two argument from 
the argument list and to apply the first to <code class="code">unit</code> and then to the second 
and to print the resulting <a href="Pretty.html#TYPEdoc"><code class="code">Pretty.doc</code></a>. For each major type in CIL there is 
a corresponding function that pretty-prints an element of that type:<br>
<pre><span class="keyword">val</span> <a name="VALd_loc"></a>d_loc : <code class="type">unit -> <a href="Cil.html#TYPElocation">location</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print a location<br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_thisloc"></a>d_thisloc : <code class="type">unit -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print the <a href="Cil.html#VALcurrentLoc"><code class="code">Cil.currentLoc</code></a><br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_ikind"></a>d_ikind : <code class="type">unit -> <a href="Cil.html#TYPEikind">ikind</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print an integer of a given kind<br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_fkind"></a>d_fkind : <code class="type">unit -> <a href="Cil.html#TYPEfkind">fkind</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print a floating-point kind<br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_storage"></a>d_storage : <code class="type">unit -> <a href="Cil.html#TYPEstorage">storage</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print storage-class information<br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_const"></a>d_const : <code class="type">unit -> <a href="Cil.html#TYPEconstant">constant</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print a constant<br>
</div>
<pre><span class="keyword">val</span> <a name="VALderefStarLevel"></a>derefStarLevel : <code class="type">int</code></pre><pre><span class="keyword">val</span> <a name="VALindexLevel"></a>indexLevel : <code class="type">int</code></pre><pre><span class="keyword">val</span> <a name="VALarrowLevel"></a>arrowLevel : <code class="type">int</code></pre><pre><span class="keyword">val</span> <a name="VALaddrOfLevel"></a>addrOfLevel : <code class="type">int</code></pre><pre><span class="keyword">val</span> <a name="VALadditiveLevel"></a>additiveLevel : <code class="type">int</code></pre><pre><span class="keyword">val</span> <a name="VALcomparativeLevel"></a>comparativeLevel : <code class="type">int</code></pre><pre><span class="keyword">val</span> <a name="VALbitwiseLevel"></a>bitwiseLevel : <code class="type">int</code></pre><pre><span class="keyword">val</span> <a name="VALgetParenthLevel"></a>getParenthLevel : <code class="type"><a href="Cil.html#TYPEexp">exp</a> -> int</code></pre><div class="info">
Parentheses level. An expression "a op b" is printed parenthesized if its 
 parentheses level is &gt;= that that of its context. Identifiers have the 
 lowest level and weakly binding operators (e.g. |) have the largest level. 
 The correctness criterion is that a smaller level MUST correspond to a 
 stronger precedence!<br>
</div>
<pre><span class="keyword">class type</span> <a name="TYPEcilPrinter"></a><a href="Cil.cilPrinter.html">cilPrinter</a> = <code class="code">object</code> <a href="Cil.cilPrinter.html">..</a> <code class="code">end</code></pre><div class="info">
A printer interface for CIL trees.
</div>
<pre><span class="keyword">class</span> <a name="TYPEdefaultCilPrinterClass"></a><a href="Cil.defaultCilPrinterClass.html">defaultCilPrinterClass</a> : <code class="type"></code><code class="type"><a href="Cil.cilPrinter.html">cilPrinter</a></code></pre><pre><span class="keyword">val</span> <a name="VALdefaultCilPrinter"></a>defaultCilPrinter : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter</a></code></pre><pre><span class="keyword">class</span> <a name="TYPEplainCilPrinterClass"></a><a href="Cil.plainCilPrinterClass.html">plainCilPrinterClass</a> : <code class="type"></code><code class="type"><a href="Cil.cilPrinter.html">cilPrinter</a></code></pre><div class="info">
These are pretty-printers that will show you more details on the internal 
 CIL representation, without trying hard to make it look like C
</div>
<pre><span class="keyword">val</span> <a name="VALplainCilPrinter"></a>plainCilPrinter : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter</a></code></pre><pre><span class="keyword">val</span> <a name="VALprinterForMaincil"></a>printerForMaincil : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter</a> Pervasives.ref</code></pre><pre><span class="keyword">val</span> <a name="VALprintType"></a>printType : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter</a> -> unit -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Print a type given a pretty printer<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprintExp"></a>printExp : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter</a> -> unit -> <a href="Cil.html#TYPEexp">exp</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Print an expression given a pretty printer<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprintLval"></a>printLval : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter</a> -> unit -> <a href="Cil.html#TYPElval">lval</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Print an lvalue given a pretty printer<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprintGlobal"></a>printGlobal : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter</a> -> unit -> <a href="Cil.html#TYPEglobal">global</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Print a global given a pretty printer<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprintAttr"></a>printAttr : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter</a> -> unit -> <a href="Cil.html#TYPEattribute">attribute</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Print an attribute given a pretty printer<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprintAttrs"></a>printAttrs : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter</a> -> unit -> <a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Print a set of attributes given a pretty printer<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprintInstr"></a>printInstr : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter</a> -> unit -> <a href="Cil.html#TYPEinstr">instr</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Print an instruction given a pretty printer<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprintStmt"></a>printStmt : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter</a> -> unit -> <a href="Cil.html#TYPEstmt">stmt</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Print a statement given a pretty printer. This can take very long 
 (or even overflow the stack) for huge statements. Use <a href="Cil.html#VALdumpStmt"><code class="code">Cil.dumpStmt</code></a> 
 instead.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprintBlock"></a>printBlock : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter</a> -> unit -> <a href="Cil.html#TYPEblock">block</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Print a block given a pretty printer. This can take very long 
 (or even overflow the stack) for huge block. Use <a href="Cil.html#VALdumpBlock"><code class="code">Cil.dumpBlock</code></a> 
 instead.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdumpStmt"></a>dumpStmt : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter</a> -> Pervasives.out_channel -> int -> <a href="Cil.html#TYPEstmt">stmt</a> -> unit</code></pre><div class="info">
Dump a statement to a file using a given indentation. Use this instead of 
 <a href="Cil.html#VALprintStmt"><code class="code">Cil.printStmt</code></a> whenever possible.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdumpBlock"></a>dumpBlock : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter</a> -> Pervasives.out_channel -> int -> <a href="Cil.html#TYPEblock">block</a> -> unit</code></pre><div class="info">
Dump a block to a file using a given indentation. Use this instead of 
 <a href="Cil.html#VALprintBlock"><code class="code">Cil.printBlock</code></a> whenever possible.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprintInit"></a>printInit : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter</a> -> unit -> <a href="Cil.html#TYPEinit">init</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Print an initializer given a pretty printer. This can take very long 
 (or even overflow the stack) for huge initializers. Use <a href="Cil.html#VALdumpInit"><code class="code">Cil.dumpInit</code></a> 
 instead.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdumpInit"></a>dumpInit : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter</a> -> Pervasives.out_channel -> int -> <a href="Cil.html#TYPEinit">init</a> -> unit</code></pre><div class="info">
Dump an initializer to a file using a given indentation. Use this instead of 
 <a href="Cil.html#VALprintInit"><code class="code">Cil.printInit</code></a> whenever possible.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_type"></a>d_type : <code class="type">unit -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print a type using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a><br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_exp"></a>d_exp : <code class="type">unit -> <a href="Cil.html#TYPEexp">exp</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print an expression using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a><br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_lval"></a>d_lval : <code class="type">unit -> <a href="Cil.html#TYPElval">lval</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print an lvalue using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a><br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_offset"></a>d_offset : <code class="type"><a href="Pretty.html#TYPEdoc">Pretty.doc</a> -> unit -> <a href="Cil.html#TYPEoffset">offset</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print an offset using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a>, given the pretty 
 printing for the base.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_init"></a>d_init : <code class="type">unit -> <a href="Cil.html#TYPEinit">init</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print an initializer using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a>.  This can be 
 extremely slow (or even overflow the stack) for huge initializers. Use 
 <a href="Cil.html#VALdumpInit"><code class="code">Cil.dumpInit</code></a> instead.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_binop"></a>d_binop : <code class="type">unit -> <a href="Cil.html#TYPEbinop">binop</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print a binary operator<br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_unop"></a>d_unop : <code class="type">unit -> <a href="Cil.html#TYPEunop">unop</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print a unary operator<br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_attr"></a>d_attr : <code class="type">unit -> <a href="Cil.html#TYPEattribute">attribute</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print an attribute using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a><br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_attrparam"></a>d_attrparam : <code class="type">unit -> <a href="Cil.html#TYPEattrparam">attrparam</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print an argument of an attribute using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a><br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_attrlist"></a>d_attrlist : <code class="type">unit -> <a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print a list of attributes using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a><br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_instr"></a>d_instr : <code class="type">unit -> <a href="Cil.html#TYPEinstr">instr</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print an instruction using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a><br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_label"></a>d_label : <code class="type">unit -> <a href="Cil.html#TYPElabel">label</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print a label using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a><br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_stmt"></a>d_stmt : <code class="type">unit -> <a href="Cil.html#TYPEstmt">stmt</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print a statement using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a>. This can be 
 extremely slow (or even overflow the stack) for huge statements. Use 
 <a href="Cil.html#VALdumpStmt"><code class="code">Cil.dumpStmt</code></a> instead.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_block"></a>d_block : <code class="type">unit -> <a href="Cil.html#TYPEblock">block</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print a block using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a>. This can be 
 extremely slow (or even overflow the stack) for huge blocks. Use 
 <a href="Cil.html#VALdumpBlock"><code class="code">Cil.dumpBlock</code></a> instead.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_global"></a>d_global : <code class="type">unit -> <a href="Cil.html#TYPEglobal">global</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print the internal representation of a global using 
 <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a>. This can be extremely slow (or even overflow the 
 stack) for huge globals (such as arrays with lots of initializers). Use 
 <a href="Cil.html#VALdumpGlobal"><code class="code">Cil.dumpGlobal</code></a> instead.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdn_exp"></a>dn_exp : <code class="type">unit -> <a href="Cil.html#TYPEexp">exp</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Versions of the above pretty printers, that don't print #line directives<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdn_lval"></a>dn_lval : <code class="type">unit -> <a href="Cil.html#TYPElval">lval</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><pre><span class="keyword">val</span> <a name="VALdn_init"></a>dn_init : <code class="type">unit -> <a href="Cil.html#TYPEinit">init</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><pre><span class="keyword">val</span> <a name="VALdn_type"></a>dn_type : <code class="type">unit -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><pre><span class="keyword">val</span> <a name="VALdn_global"></a>dn_global : <code class="type">unit -> <a href="Cil.html#TYPEglobal">global</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><pre><span class="keyword">val</span> <a name="VALdn_attrlist"></a>dn_attrlist : <code class="type">unit -> <a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><pre><span class="keyword">val</span> <a name="VALdn_attr"></a>dn_attr : <code class="type">unit -> <a href="Cil.html#TYPEattribute">attribute</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><pre><span class="keyword">val</span> <a name="VALdn_attrparam"></a>dn_attrparam : <code class="type">unit -> <a href="Cil.html#TYPEattrparam">attrparam</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><pre><span class="keyword">val</span> <a name="VALdn_stmt"></a>dn_stmt : <code class="type">unit -> <a href="Cil.html#TYPEstmt">stmt</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><pre><span class="keyword">val</span> <a name="VALdn_instr"></a>dn_instr : <code class="type">unit -> <a href="Cil.html#TYPEinstr">instr</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><pre><span class="keyword">val</span> <a name="VALd_shortglobal"></a>d_shortglobal : <code class="type">unit -> <a href="Cil.html#TYPEglobal">global</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print a short description of the global. This is useful for error 
 messages<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdumpGlobal"></a>dumpGlobal : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter</a> -> Pervasives.out_channel -> <a href="Cil.html#TYPEglobal">global</a> -> unit</code></pre><div class="info">
Pretty-print a global. Here you give the channel where the printout
 should be sent.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdumpFile"></a>dumpFile : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter</a> -> Pervasives.out_channel -> string -> <a href="Cil.html#TYPEfile">file</a> -> unit</code></pre><div class="info">
Pretty-print an entire file. Here you give the channel where the printout
 should be sent.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbug"></a>bug : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc</a>) Pervasives.format -> 'a</code></pre><div class="info">
Like <a href="Errormsg.html#VALbug"><code class="code">Errormsg.bug</code></a> except that <a href="Cil.html#VALcurrentLoc"><code class="code">Cil.currentLoc</code></a> is also printed<br>
</div>
<pre><span class="keyword">val</span> <a name="VALunimp"></a>unimp : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc</a>) Pervasives.format -> 'a</code></pre><div class="info">
Like <a href="Errormsg.html#VALunimp"><code class="code">Errormsg.unimp</code></a> except that <a href="Cil.html#VALcurrentLoc"><code class="code">Cil.currentLoc</code></a>is also printed<br>
</div>
<pre><span class="keyword">val</span> <a name="VALerror"></a>error : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc</a>) Pervasives.format -> 'a</code></pre><div class="info">
Like <a href="Errormsg.html#VALerror"><code class="code">Errormsg.error</code></a> except that <a href="Cil.html#VALcurrentLoc"><code class="code">Cil.currentLoc</code></a> is also printed<br>
</div>
<pre><span class="keyword">val</span> <a name="VALerrorLoc"></a>errorLoc : <code class="type"><a href="Cil.html#TYPElocation">location</a> -> ('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc</a>) Pervasives.format -> 'a</code></pre><div class="info">
Like <a href="Cil.html#VALerror"><code class="code">Cil.error</code></a> except that it explicitly takes a location argument, 
 instead of using the <a href="Cil.html#VALcurrentLoc"><code class="code">Cil.currentLoc</code></a><br>
</div>
<pre><span class="keyword">val</span> <a name="VALwarn"></a>warn : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc</a>) Pervasives.format -> 'a</code></pre><div class="info">
Like <a href="Errormsg.html#VALwarn"><code class="code">Errormsg.warn</code></a> except that <a href="Cil.html#VALcurrentLoc"><code class="code">Cil.currentLoc</code></a> is also printed<br>
</div>
<pre><span class="keyword">val</span> <a name="VALwarnOpt"></a>warnOpt : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc</a>) Pervasives.format -> 'a</code></pre><div class="info">
Like <a href="Errormsg.html#VALwarnOpt"><code class="code">Errormsg.warnOpt</code></a> except that <a href="Cil.html#VALcurrentLoc"><code class="code">Cil.currentLoc</code></a> is also printed. 
 This warning is printed only of <a href="Errormsg.html#VALwarnFlag"><code class="code">Errormsg.warnFlag</code></a> is set.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALwarnContext"></a>warnContext : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc</a>) Pervasives.format -> 'a</code></pre><div class="info">
Like <a href="Errormsg.html#VALwarn"><code class="code">Errormsg.warn</code></a> except that <a href="Cil.html#VALcurrentLoc"><code class="code">Cil.currentLoc</code></a> and context 
    is also printed<br>
</div>
<pre><span class="keyword">val</span> <a name="VALwarnContextOpt"></a>warnContextOpt : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc</a>) Pervasives.format -> 'a</code></pre><div class="info">
Like <a href="Errormsg.html#VALwarn"><code class="code">Errormsg.warn</code></a> except that <a href="Cil.html#VALcurrentLoc"><code class="code">Cil.currentLoc</code></a> and context is also 
 printed. This warning is printed only of <a href="Errormsg.html#VALwarnFlag"><code class="code">Errormsg.warnFlag</code></a> is set.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALwarnLoc"></a>warnLoc : <code class="type"><a href="Cil.html#TYPElocation">location</a> -> ('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc</a>) Pervasives.format -> 'a</code></pre><div class="info">
Like <a href="Cil.html#VALwarn"><code class="code">Cil.warn</code></a> except that it explicitly takes a location argument, 
 instead of using the <a href="Cil.html#VALcurrentLoc"><code class="code">Cil.currentLoc</code></a><br>
</div>
<br>
Sometimes you do not want to see the syntactic sugar that the above 
 pretty-printing functions add. In that case you can use the following 
 pretty-printing functions. But note that the output of these functions is 
 not valid C<br>
<pre><span class="keyword">val</span> <a name="VALd_plainexp"></a>d_plainexp : <code class="type">unit -> <a href="Cil.html#TYPEexp">exp</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print the internal representation of an expression<br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_plaininit"></a>d_plaininit : <code class="type">unit -> <a href="Cil.html#TYPEinit">init</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print the internal representation of an integer<br>
</div>
<pre><span class="keyword">val</span> <a name="VALd_plainlval"></a>d_plainlval : <code class="type">unit -> <a href="Cil.html#TYPElval">lval</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print the internal representation of an lvalue<br>
</div>
<br>
Pretty-print the internal representation of an lvalue offset 
val d_plainoffset: unit -&gt; offset -&gt; Pretty.doc<br>
<pre><span class="keyword">val</span> <a name="VALd_plaintype"></a>d_plaintype : <code class="type">unit -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-print the internal representation of a type<br>
</div>
<br>
<b>ALPHA conversion</b> has been moved to the Alpha module.<br>
<pre><span class="keyword">val</span> <a name="VALuniqueVarNames"></a>uniqueVarNames : <code class="type"><a href="Cil.html#TYPEfile">file</a> -> unit</code></pre><div class="info">
Assign unique names to local variables. This might be necessary after you 
 transformed the code and added or renamed some new variables. Names are 
 not used by CIL internally, but once you print the file out the compiler 
 downstream might be confused. You might 
 have added a new global that happens to have the same name as a local in 
 some function. Rename the local to ensure that there would never be 
 confusioin. Or, viceversa, you might have added a local with a name that 
 conflicts with a global<br>
</div>
<br>
<b>Optimization Passes</b><br>
<pre><span class="keyword">val</span> <a name="VALpeepHole2"></a>peepHole2 : <code class="type">(<a href="Cil.html#TYPEinstr">instr</a> * <a href="Cil.html#TYPEinstr">instr</a> -> <a href="Cil.html#TYPEinstr">instr</a> list option) -> <a href="Cil.html#TYPEstmt">stmt</a> list -> unit</code></pre><div class="info">
A peephole optimizer that processes two adjacent statements and possibly 
    replaces them both. If some replacement happens, then the new statements 
    are themselves subject to optimization<br>
</div>
<pre><span class="keyword">val</span> <a name="VALpeepHole1"></a>peepHole1 : <code class="type">(<a href="Cil.html#TYPEinstr">instr</a> -> <a href="Cil.html#TYPEinstr">instr</a> list option) -> <a href="Cil.html#TYPEstmt">stmt</a> list -> unit</code></pre><div class="info">
Similar to <code class="code">peepHole2</code> except that the optimization window consists of 
    one statement, not two<br>
</div>
<br>
<b>Machine dependency</b><br>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONSizeOfError"></a>SizeOfError <span class="keyword">of</span> <code class="type">string * <a href="Cil.html#TYPEtyp">typ</a></code></pre>
<div class="info">
Raised when one of the bitsSizeOf functions cannot compute the size of a 
 type. This can happen because the type contains array-length expressions 
 that we don't know how to compute or because it is a type whose size is 
 not defined (e.g. TFun or an undefined compinfo). The string is an 
 explanation of the error<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbitsSizeOf"></a>bitsSizeOf : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> int</code></pre><div class="info">
The size of a type, in bits. Trailing padding is added for structs and 
 arrays. Raises <a href="Cil.html#EXCEPTIONSizeOfError"><code class="code">Cil.SizeOfError</code></a> when it cannot compute the size. This 
 function is architecture dependent, so you should only call this after you 
 call <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a>. Remember that on GCC sizeof(void) is 1!<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsizeOf"></a>sizeOf : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEexp">exp</a></code></pre><pre><span class="keyword">val</span> <a name="VALalignOf_int"></a>alignOf_int : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> int</code></pre><div class="info">
The minimum alignment (in bytes) for a type. This function is 
 architecture dependent, so you should only call this after you call 
 <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbitsOffset"></a>bitsOffset : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEoffset">offset</a> -> int * int</code></pre><div class="info">
Give a type of a base and an offset, returns the number of bits from the 
 base address and the width (also expressed in bits) for the subobject 
 denoted by the offset. Raises <a href="Cil.html#EXCEPTIONSizeOfError"><code class="code">Cil.SizeOfError</code></a> when it cannot compute 
 the size. This function is architecture dependent, so you should only call 
 this after you call <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALchar_is_unsigned"></a>char_is_unsigned : <code class="type">bool Pervasives.ref</code></pre><div class="info">
Whether "char" is unsigned. Set after you call <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a><br>
</div>
<pre><span class="keyword">val</span> <a name="VALlittle_endian"></a>little_endian : <code class="type">bool Pervasives.ref</code></pre><div class="info">
Whether the machine is little endian. Set after you call <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a><br>
</div>
<pre><span class="keyword">val</span> <a name="VALunderscore_name"></a>underscore_name : <code class="type">bool Pervasives.ref</code></pre><div class="info">
Whether the compiler generates assembly labels by prepending "_" to the 
    identifier. That is, will function foo() have the label "foo", or "_foo"?
    Set after you call <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a><br>
</div>
<pre><span class="keyword">val</span> <a name="VALlocUnknown"></a>locUnknown : <code class="type"><a href="Cil.html#TYPElocation">location</a></code></pre><div class="info">
Represents a location that cannot be determined<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_instrLoc"></a>get_instrLoc : <code class="type"><a href="Cil.html#TYPEinstr">instr</a> -> <a href="Cil.html#TYPElocation">location</a></code></pre><div class="info">
Return the location of an instruction<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_globalLoc"></a>get_globalLoc : <code class="type"><a href="Cil.html#TYPEglobal">global</a> -> <a href="Cil.html#TYPElocation">location</a></code></pre><div class="info">
Return the location of a global, or locUnknown<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_stmtLoc"></a>get_stmtLoc : <code class="type"><a href="Cil.html#TYPEstmtkind">stmtkind</a> -> <a href="Cil.html#TYPElocation">location</a></code></pre><div class="info">
Return the location of a statement, or locUnknown<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdExp"></a>dExp : <code class="type"><a href="Pretty.html#TYPEdoc">Pretty.doc</a> -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info">
Generate an <a href="Cil.html#TYPEexp"><code class="code">Cil.exp</code></a> to be used in case of errors.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdInstr"></a>dInstr : <code class="type"><a href="Pretty.html#TYPEdoc">Pretty.doc</a> -> <a href="Cil.html#TYPElocation">location</a> -> <a href="Cil.html#TYPEinstr">instr</a></code></pre><div class="info">
Generate an <a href="Cil.html#TYPEinstr"><code class="code">Cil.instr</code></a> to be used in case of errors.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdGlobal"></a>dGlobal : <code class="type"><a href="Pretty.html#TYPEdoc">Pretty.doc</a> -> <a href="Cil.html#TYPElocation">location</a> -> <a href="Cil.html#TYPEglobal">global</a></code></pre><div class="info">
Generate a <a href="Cil.html#TYPEglobal"><code class="code">Cil.global</code></a> to be used in case of errors.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmapNoCopy"></a>mapNoCopy : <code class="type">('a -> 'a) -> 'a list -> 'a list</code></pre><div class="info">
Like map but try not to make a copy of the list<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmapNoCopyList"></a>mapNoCopyList : <code class="type">('a -> 'a list) -> 'a list -> 'a list</code></pre><div class="info">
Like map but each call can return a list. Try not to make a copy of the 
    list<br>
</div>
<pre><span class="keyword">val</span> <a name="VALstartsWith"></a>startsWith : <code class="type">string -> string -> bool</code></pre><div class="info">
sm: return true if the first is a prefix of the second string<br>
</div>
<br>
<b>An Interpreter for constructing CIL constructs</b><br>
<br><code><span class="keyword">type</span> <a name="TYPEformatArg"></a><code class="type"></code>formatArg = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Fe</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Feo</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a> option</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>For array lengths</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Fu</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEunop">unop</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Fb</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEbinop">binop</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Fk</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEikind">ikind</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">FE</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a> list</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>For arguments in a function call</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Ff</span> <span class="keyword">of</span> <code class="type">(string * <a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEattributes">attributes</a>)</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>For a formal argument</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">FF</span> <span class="keyword">of</span> <code class="type">(string * <a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEattributes">attributes</a>) list</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>For formal argument lists</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Fva</span> <span class="keyword">of</span> <code class="type">bool</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code>For the ellipsis in a function type</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Fv</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Fl</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPElval">lval</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Flo</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPElval">lval</a> option</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Fo</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEoffset">offset</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Fc</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEcompinfo">compinfo</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Fi</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEinstr">instr</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">FI</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEinstr">instr</a> list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Ft</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Fd</span> <span class="keyword">of</span> <code class="type">int</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Fg</span> <span class="keyword">of</span> <code class="type">string</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Fs</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEstmt">stmt</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">FS</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEstmt">stmt</a> list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">FA</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattributes">attributes</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Fp</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattrparam">attrparam</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">FP</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattrparam">attrparam</a> list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">FX</span> <span class="keyword">of</span> <code class="type">string</code></code></td>

</tr></table>

<div class="info">
The type of argument for the interpreter<br>
</div>

<pre><span class="keyword">val</span> <a name="VALd_formatarg"></a>d_formatarg : <code class="type">unit -> <a href="Cil.html#TYPEformatArg">formatArg</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info">
Pretty-prints a format arg<br>
</div>
<pre><span class="keyword">val</span> <a name="VALlowerConstants"></a>lowerConstants : <code class="type">bool Pervasives.ref</code></pre><div class="info">
Do lower constant expressions into constants (default true)<br>
</div>
</body></html>